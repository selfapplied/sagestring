<!DOCTYPE html>
<html>
<head>
    <title>CE Tower Interactive Exhibit: Theory Meets Implementation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }
        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 20px;
            border-bottom: 2px solid #4ecdc4;
            text-align: center;
        }
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: #4ecdc4;
        }
        .header p {
            font-size: 14px;
            color: #888;
            max-width: 800px;
            margin: 0 auto;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            padding: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }
        .main-panel {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 20px;
        }
        .ce-layers {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        .ce-layer {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            position: relative;
        }
        .ce-layer.ce1 {
            border-color: #4ecdc4;
        }
        .ce-layer.ce2 {
            border-color: #45b7d1;
        }
        .ce-layer.ce3 {
            border-color: #f9ca24;
        }
        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .layer-title {
            font-size: 18px;
            font-weight: bold;
        }
        .ce1 .layer-title { color: #4ecdc4; }
        .ce2 .layer-title { color: #45b7d1; }
        .ce3 .layer-title { color: #f9ca24; }
        .layer-status {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #0f0f0f;
        }
        .status-active { background: #2a5a2a; color: #4ecdc4; }
        .status-evolution { background: #5a4a2a; color: #f9ca24; }
        .viz-container {
            background: #000;
            border: 1px solid #444;
            border-radius: 4px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        .viz-container canvas {
            width: 100%;
            height: 200px;
            display: block;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
            font-size: 11px;
        }
        .metric {
            background: #0f0f0f;
            padding: 6px;
            border-radius: 4px;
        }
        .metric-label {
            color: #888;
            font-size: 10px;
        }
        .metric-value {
            color: #4ecdc4;
            font-weight: bold;
            font-size: 14px;
        }
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .panel {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }
        .panel h3 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #4ecdc4;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
        }
        .controls {
            display: grid;
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .control-group label {
            font-size: 12px;
            color: #888;
        }
        input[type="range"] {
            width: 100%;
        }
        .control-value {
            font-size: 11px;
            color: #4ecdc4;
            text-align: right;
        }
        button {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover {
            background: #3a3a3a;
            border-color: #4ecdc4;
        }
        button:active {
            background: #4a4a4a;
        }
        button.primary {
            background: #4ecdc4;
            color: #0a0a0a;
            border-color: #4ecdc4;
        }
        button.primary:hover {
            background: #5eddd4;
        }
        .invariants-display {
            font-size: 11px;
            line-height: 1.6;
        }
        .invariant-item {
            margin: 8px 0;
            padding: 8px;
            background: #0f0f0f;
            border-radius: 4px;
            border-left: 3px solid #4ecdc4;
        }
        .invariant-name {
            font-weight: bold;
            color: #4ecdc4;
        }
        .invariant-value {
            color: #888;
            font-family: 'Courier New', monospace;
        }
        .guardian-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        .guardian {
            background: #0f0f0f;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
            border: 1px solid #333;
        }
        .guardian.phi { border-color: #ff6b6b; }
        .guardian.partial { border-color: #4ecdc4; }
        .guardian.scriptr { border-color: #f9ca24; }
        .guardian-name {
            font-size: 10px;
            color: #888;
            margin-bottom: 4px;
        }
        .guardian-value {
            font-size: 18px;
            font-weight: bold;
        }
        .guardian.phi .guardian-value { color: #ff6b6b; }
        .guardian.partial .guardian-value { color: #4ecdc4; }
        .guardian.scriptr .guardian-value { color: #f9ca24; }
        .paper-link {
            margin-top: 20px;
            padding: 15px;
            background: #0f0f0f;
            border-radius: 4px;
            border: 1px solid #4ecdc4;
            text-align: center;
        }
        .paper-link a {
            color: #4ecdc4;
            text-decoration: none;
            font-size: 14px;
        }
        .paper-link a:hover {
            text-decoration: underline;
        }
        .evolution-log {
            max-height: 200px;
            overflow-y: auto;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            background: #0f0f0f;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        .log-entry {
            margin: 4px 0;
            padding: 4px;
            border-left: 2px solid #333;
            padding-left: 8px;
        }
        .log-entry.error-lift {
            border-left-color: #f9ca24;
            color: #f9ca24;
        }
        .log-entry.guardian {
            border-left-color: #4ecdc4;
            color: #4ecdc4;
        }
        .log-entry.evolution {
            border-left-color: #45b7d1;
            color: #45b7d1;
        }
        input[type="file"] {
            display: none;
        }
        .upload-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        .upload-hint {
            font-size: 10px;
            color: #666;
            margin-top: 8px;
            text-align: center;
            font-style: italic;
        }
        .video-section {
            margin-top: 20px;
            padding: 15px;
            background: #0f0f0f;
            border-radius: 4px;
            border: 1px solid #4ecdc4;
        }
        .video-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .video-btn {
            padding: 8px 16px;
            background: #1a1a2e;
            border: 1px solid #4ecdc4;
            color: #4ecdc4;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            transition: all 0.2s;
        }
        .video-btn:hover {
            background: #4ecdc4;
            color: #0a0a0a;
        }
        .video-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .video-btn.active {
            background: #4ecdc4;
            color: #0a0a0a;
        }
        .video-container {
            position: relative;
            background: #000;
            border: 1px solid #444;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .video-container video {
            width: 100%;
            display: block;
        }
        .video-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .video-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }
        .video-stat {
            background: #0f0f0f;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        .video-stat-label {
            color: #888;
            margin-bottom: 4px;
        }
        .video-stat-value {
            color: #4ecdc4;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîÆ CE Tower Interactive Exhibit</h1>
        <p>Real-time visualization of the three-layer functorial architecture: CE1 (Discrete Grammar), CE2 (Dynamical Flow), CE3 (Emergent Simplicial)</p>
        <p style="margin-top: 8px; font-size: 12px; color: #666;">Theory meets implementation: SVG kernels as CE1 operators, cellular automata as CE2 flows, error-lift as CE3 evolution</p>
    </div>

    <div class="container">
        <div class="main-panel">
            <div class="ce-layers">
                <!-- CE1: Discrete Grammar Category -->
                <div class="ce-layer ce1">
                    <div class="layer-header">
                        <div>
                            <div class="layer-title">CE1: Discrete Grammar</div>
                            <div style="font-size: 11px; color: #888; margin-top: 4px;">Bracket topology, operator algebra</div>
                        </div>
                        <div class="layer-status status-active">ACTIVE</div>
                    </div>
                    <div class="viz-container">
                        <canvas id="ce1-canvas" width="300" height="200"></canvas>
                    </div>
                    <div class="viz-container" id="ce1-svg-container" style="margin-top: 10px; min-height: 200px; background: #000; border: 1px solid #4ecdc4; border-radius: 4px; padding: 10px; display: none;">
                        <div style="font-size: 10px; color: #4ecdc4; margin-bottom: 8px;">Real-Time SVG Evolution</div>
                        <div id="ce1-svg-display" style="width: 100%; height: 200px; overflow: auto;"></div>
                    </div>
                    <div class="metrics">
                        <div class="metric">
                            <div class="metric-label">Bracket Depth</div>
                            <div class="metric-value" id="bracket-depth">0</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Operators</div>
                            <div class="metric-value" id="operator-count">4</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Kernels</div>
                            <div class="metric-value" id="kernel-count">0</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Ultrametric d</div>
                            <div class="metric-value" id="ultrametric">1.0</div>
                        </div>
                    </div>
                </div>

                <!-- CE2: Dynamical Flow Category -->
                <div class="ce-layer ce2">
                    <div class="layer-header">
                        <div>
                            <div class="layer-title">CE2: Dynamical Flow</div>
                            <div style="font-size: 11px; color: #888; margin-top: 4px;">Guardian-modulated attention, phase coherence</div>
                        </div>
                        <div class="layer-status status-active">FLOWING</div>
                    </div>
                    <div class="viz-container">
                        <canvas id="ce2-canvas" width="300" height="200"></canvas>
                    </div>
                    <div class="guardian-display">
                        <div class="guardian phi">
                            <div class="guardian-name">œï (Phase)</div>
                            <div class="guardian-value" id="guardian-phi">0.85</div>
                        </div>
                        <div class="guardian partial">
                            <div class="guardian-name">‚àÇ (Structure)</div>
                            <div class="guardian-value" id="guardian-partial">0.92</div>
                        </div>
                        <div class="guardian scriptr">
                            <div class="guardian-name">‚Ñõ (Coherence)</div>
                            <div class="guardian-value" id="guardian-scriptr">0.88</div>
                        </div>
                    </div>
                    <div class="metrics" style="margin-top: 10px;">
                        <div class="metric">
                            <div class="metric-label">Antclock A</div>
                            <div class="metric-value" id="antclock">0</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Edge Strength E</div>
                            <div class="metric-value" id="edge-strength">0.12</div>
                        </div>
                    </div>
                </div>

                <!-- CE3: Emergent Simplicial Category -->
                <div class="ce-layer ce3">
                    <div class="layer-header">
                        <div>
                            <div class="layer-title">CE3: Emergent Simplicial</div>
                            <div style="font-size: 11px; color: #888; margin-top: 4px;">
                                Simplicial = triangular decompositions<br>
                                Emergent = errors ‚Üí new grammar structure
                            </div>
                        </div>
                        <div class="layer-status" id="ce3-status">STABLE</div>
                    </div>
                    <div class="viz-container">
                        <canvas id="ce3-canvas" width="300" height="200"></canvas>
                    </div>
                    <div class="metrics">
                        <div class="metric">
                            <div class="metric-label">Discrepancy Œ¥</div>
                            <div class="metric-value" id="discrepancy">0.08</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Error-Lifts</div>
                            <div class="metric-value" id="error-lifts">0</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Expressivity E</div>
                            <div class="metric-value" id="expressivity">1.0</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Œ∂ Attractor</div>
                            <div class="metric-value" id="zeta-distance">0.05</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel" style="margin-top: 20px;">
                <h3>CE Tower Integration: Complete Loop</h3>
                <div class="viz-container" style="height: 300px;">
                    <canvas id="integration-canvas" width="800" height="300"></canvas>
                </div>
            </div>
        </div>

        <div class="side-panel">
            <div class="panel">
                <h3>System Controls</h3>
                <div class="controls">
                    <button class="primary" onclick="initializeCETower()">Initialize CE Tower</button>
                    <button onclick="createKernel()">Create SVG Kernel</button>
                    <button onclick="evolveStep()" title="Run one CE Tower cycle: CE2 evolution ‚Üí Guardian update ‚Üí CE3 error-lift check">
                        ‚è≠Ô∏è Evolve One Step
                    </button>
                    <button onclick="triggerErrorLift()">Trigger Error-Lift</button>
                    <button onclick="resetSystem()">Reset System</button>
                </div>
                <div style="font-size: 10px; color: #666; margin-top: 8px; padding: 8px; background: #0f0f0f; border-radius: 4px;">
                    <strong>Evolve One Step</strong> runs the complete CE Tower loop:<br>
                    ‚Ä¢ CE2: Lattice evolution (cellular automata)<br>
                    ‚Ä¢ CE2: Guardian update (Sobel edge detection)<br>
                    ‚Ä¢ CE3: Error-lift check (grammar evolution if Œ¥ > Œ∫)<br>
                    ‚Ä¢ Advance antclock (experiential time)
                </div>
                <div class="upload-section">
                    <label style="display: block; margin-bottom: 8px; font-size: 12px; color: #888;">
                        üì∑ Upload Image for CE Tower Processing
                    </label>
                    <input type="file" id="image-upload" accept="image/*" onchange="handleImageUpload(event)">
                    <button onclick="document.getElementById('image-upload').click()" style="width: 100%; background: #2a5a2a; border-color: #4ecdc4; color: #4ecdc4;">
                        Choose Image File
                    </button>
                    <div class="upload-hint">
                        Image ‚Üí CE1 Kernel ‚Üí CE2 Sobel Edges ‚Üí CE3 Evolution
                    </div>
                </div>
                
                <div class="video-section">
                    <h3 style="margin-bottom: 15px; color: #4ecdc4;">üìπ Real-Time Video Processing</h3>
                    <div class="video-controls">
                        <button class="video-btn" id="start-video-btn" onclick="startVideoCapture()">üé• Start Camera</button>
                        <button class="video-btn" id="stop-video-btn" onclick="stopVideoCapture()" disabled>‚èπÔ∏è Stop Camera</button>
                        <button class="video-btn" id="toggle-svg-btn" onclick="toggleSVGDisplay()">üé® Toggle SVG</button>
                    </div>
                    <div class="video-container" id="video-container" style="display: none;">
                        <video id="video-element" autoplay muted playsinline></video>
                        <canvas id="video-overlay"></canvas>
                    </div>
                    <div class="video-stats" id="video-stats" style="display: none;">
                        <div class="video-stat">
                            <div class="video-stat-label">FPS</div>
                            <div class="video-stat-value" id="video-fps">0</div>
                        </div>
                        <div class="video-stat">
                            <div class="video-stat-label">Frame</div>
                            <div class="video-stat-value" id="video-frame">0</div>
                        </div>
                        <div class="video-stat">
                            <div class="video-stat-label">Processing</div>
                            <div class="video-stat-value" id="video-processing">0ms</div>
                        </div>
                    </div>
                    <div style="font-size: 10px; color: #666; margin-top: 10px; padding: 8px; background: #0f0f0f; border-radius: 4px;">
                        <strong>Live Video ‚Üí CE Tower:</strong><br>
                        ‚Ä¢ Real-time edge detection with antclock drift correction<br>
                        ‚Ä¢ Temporal coherence across frames<br>
                        ‚Ä¢ Continuous evolution with guardian modulation
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Guardian Threshold Œ∫</h3>
                <div class="control-group">
                    <label>Threshold Parameter (Œ∫ = 0.35 optimal)</label>
                    <input type="range" id="kappa-slider" min="0.1" max="0.9" step="0.05" value="0.35">
                    <div class="control-value" id="kappa-value">0.35</div>
                </div>
                <div style="font-size: 11px; color: #888; margin-top: 10px;">
                    Below Œ∫: Safe composition<br>
                    Above Œ∫: Error-lift triggered
                </div>
            </div>

            <div class="panel">
                <h3>Computable Invariants</h3>
                <div class="invariants-display">
                    <div class="invariant-item">
                        <div class="invariant-name">œÄ (Closure)</div>
                        <div class="invariant-value">3.14159...</div>
                    </div>
                    <div class="invariant-item">
                        <div class="invariant-name">i (Phase)</div>
                        <div class="invariant-value">‚àö(-1)</div>
                    </div>
                    <div class="invariant-item">
                        <div class="invariant-name">e (Exponential)</div>
                        <div class="invariant-value">2.71828...</div>
                    </div>
                    <div class="invariant-item">
                        <div class="invariant-name">‚Ñè (Quantum)</div>
                        <div class="invariant-value">1.05457... √ó 10‚Åª¬≥‚Å¥</div>
                    </div>
                    <div class="invariant-item">
                        <div class="invariant-name">œá_FEG</div>
                        <div class="invariant-value">0.638</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Evolution Log</h3>
                <div class="evolution-log" id="evolution-log">
                    <div class="log-entry">System ready. Initialize to begin.</div>
                </div>
            </div>

            <div class="panel">
                <h3>Witness Fingerprints</h3>
                <div class="invariants-display" id="witness-fingerprints">
                    <div class="invariant-item">
                        <div class="invariant-name">No witnesses yet</div>
                        <div class="invariant-value">Create kernels to generate 4D signatures</div>
                    </div>
                </div>
            </div>

            <div class="panel" style="margin-top: 20px;">
                <h3>Self-Referential Fractal Sobel</h3>
                <div style="font-size: 11px; line-height: 1.6; color: #ccc;">
                    <p style="margin-bottom: 10px;">
                        <strong style="color: #45b7d1;">Perceptual Bootloader</strong>: Edges reshape kernels, kernels reshape edges.
                        The detector becomes a living creature tracing its own silhouette.
                    </p>
                    <p style="margin-bottom: 10px;">
                        <strong>Self-Referential Update</strong>: K(s,t+1) = U(K(s,t), E_s(t))
                        <br>‚Ä¢ <strong>Feature Attraction</strong>: Strengthen directions where edges persist
                        <br>‚Ä¢ <strong>Noise Repulsion</strong>: Suppress incoherent high-frequency noise
                        <br>‚Ä¢ <strong>Energy Invariance</strong>: Preserve total kernel energy (L¬π norm)
                        <br>‚Ä¢ <strong>Smoothness</strong>: Maintain differentiability class
                    </p>
                    <p style="margin-bottom: 10px;">
                        <strong>Fixed-Point Convergence</strong>: Kernels evolve toward coherent internal model.
                        The system converges when kernel updates shrink below threshold Œµ.
                    </p>
                    <p style="font-size: 10px; color: #888; font-style: italic; margin-top: 10px;">
                        "The detector shapes the perception that shapes the detector."
                    </p>
                </div>
            </div>

            <div class="panel" style="margin-top: 20px;">
                <h3>What is "Emergent Simplicial"?</h3>
                <div style="font-size: 11px; line-height: 1.6; color: #ccc;">
                    <p style="margin-bottom: 10px;">
                        <strong style="color: #f9ca24;">Simplicial</strong> = Geometric structures (triangles, tetrahedra) that represent 
                        <strong>grammatical decompositions</strong>. Just as triangles can tile any 2D surface, 
                        simplicial structures can decompose any compositional space.
                    </p>
                    <p style="margin-bottom: 10px;">
                        <strong style="color: #f9ca24;">Emergent</strong> = New structure <strong>arises from discrepancies</strong>. 
                        When the system encounters patterns it can't express, it doesn't fail‚Äîit evolves the grammar itself.
                    </p>
                    <p style="margin-bottom: 10px;">
                        <strong>Error-Lift Operator (ùîà)</strong>: Transforms discrepancies Œ¥ into new grammatical structure. 
                        "If something doesn't fit the grammar, the grammar must grow."
                    </p>
                    <p style="margin-bottom: 10px;">
                        <strong>Œ∂ Attractor</strong>: The recursive identity (self ‚Ü¶ self) that stabilizes emergent patterns 
                        through self-recognition. New structures must achieve self-recognition to persist.
                    </p>
                    <p style="font-size: 10px; color: #888; font-style: italic; margin-top: 10px;">
                        Paper Section 3.3: "CE3 is the bold layer‚Äîwhere nothing is an error anymore. 
                        Compositional discrepancies become generative tension birthing new structure."
                    </p>
                </div>
            </div>

            <div class="paper-link">
                <a href="#" onclick="showPaperInfo()">üìÑ View Research Paper</a>
            </div>
        </div>
    </div>

    <script src="svg_kernel_system.js"></script>
    <script src="svg_kernel_cv_system.js"></script>
    <script>
        // CE Tower Interactive Exhibit
        let kernelSystem;
        let cvSystem = null;
        let isInitialized = false;
        let currentKernels = [];
        let antclock = 0;
        let errorLiftCount = 0;
        let expressivity = 1.0;
        let kappa = 0.35;
        
        // Video processing state
        let videoStream = null;
        let videoElement = null;
        let videoOverlay = null;
        let isVideoProcessing = false;
        let videoKernel = null; // Kernel created from video frames
        let frameCounter = 0;
        let showSVG = false; // Toggle for SVG display
        let lastFrameTime = 0;
        let frameTimeHistory = [];
        let lastVideoTime = -1; // Track video currentTime to detect new frames

        // Guardian values
        let guardianPhi = 0.85;
        let guardianPartial = 0.92;
        let guardianScriptR = 0.88;

        // Canvas contexts
        const ce1Canvas = document.getElementById('ce1-canvas');
        const ce1Ctx = ce1Canvas.getContext('2d');
        const ce2Canvas = document.getElementById('ce2-canvas');
        const ce2Ctx = ce2Canvas.getContext('2d');
        const ce3Canvas = document.getElementById('ce3-canvas');
        const ce3Ctx = ce3Canvas.getContext('2d');
        const integrationCanvas = document.getElementById('integration-canvas');
        const integrationCtx = integrationCanvas.getContext('2d');

        function initializeCETower() {
            logEntry('Initializing CE Tower architecture...', 'evolution');
            
            kernelSystem = new SVGKernelSystem();
            isInitialized = true;
            antclock = 0;
            errorLiftCount = 0;
            expressivity = 1.0;

            // Initialize canvases
            clearCanvas(ce1Ctx, ce1Canvas);
            clearCanvas(ce2Ctx, ce2Canvas);
            clearCanvas(ce3Ctx, ce3Canvas);
            clearCanvas(integrationCtx, integrationCanvas);

            // Draw CE1 structure
            drawCE1Structure();
            
            logEntry('CE Tower initialized. CE1: Discrete Grammar active.', 'evolution');
            logEntry('CE2: Dynamical Flow ready. CE3: Emergent Simplicial stable.', 'evolution');
            
            updateDisplay();
        }

        function createKernel() {
            if (!isInitialized) {
                alert('Initialize CE Tower first!');
                return;
            }

            const kernelTypes = ['spiral', 'wave', 'circle'];
            const kernelType = kernelTypes[Math.floor(Math.random() * kernelTypes.length)];

            const kernelXML = getKernelXML(kernelType);
            const kernels = kernelSystem.parseKernel(kernelXML);
            
            for (const kernel of kernels) {
                kernelSystem.discretizeKernel(kernel);
                currentKernels.push(kernel);
                
                logEntry(`CE1: Created ${kernelType} kernel (energy=${kernel.energy}, power=${kernel.power})`, 'evolution');
                
                // Generate witness fingerprint
                const fingerprint = generateWitnessFingerprint(kernel);
                addWitnessFingerprint(kernel.id, fingerprint);
            }

            updateDisplay();
        }

        function getKernelXML(type) {
            const kernels = {
                spiral: `<kernel id="spiral_${Date.now()}" energy="1.2" power="2.0">
                    <shape><path d="M128 128 L128 108 A20 20 0 0 1 148 128 L168 128 A40 40 0 0 0 128 168 L128 188 A60 60 0 0 1 68 128 L48 128 A80 80 0 0 0 128 48 Z" stroke="#00ff88" stroke-width="3"/></shape>
                    <discrete><lattice size="256" boundary="wrap"/></discrete>
                    <invariants><scale-invariance/><mirror-symmetry/></invariants>
                </kernel>`,
                wave: `<kernel id="wave_${Date.now()}" energy="1.0" power="1.8">
                    <shape><path d="M0 128 Q64 64 128 128 T256 128" stroke="#0088ff" stroke-width="4"/></shape>
                    <discrete><lattice size="256" boundary="wrap"/></discrete>
                    <invariants><scale-invariance/></invariants>
                </kernel>`,
                circle: `<kernel id="circle_${Date.now()}" energy="1.5" power="2.2">
                    <shape><circle cx="128" cy="128" r="60" stroke="#ff8800" stroke-width="4"/></shape>
                    <discrete><lattice size="256" boundary="wrap"/></discrete>
                    <invariants><scale-invariance/><rotation-invariance/></invariants>
                </kernel>`
            };
            return kernels[type];
        }

        /**
         * Evolve One Step: Runs one complete CE Tower cycle with edge refinement
         * 
         * This executes the closed-loop architecture:
         * 1. CE2: Compute/update edges (Sobel detection)
         * 2. CE2: Evolve lattice with edge-preserving dynamics
         * 3. CE2: Refine edges based on evolution
         * 4. CE2: Update guardians (œï, ‚àÇ, ‚Ñõ metrics)
         * 5. CE3: Check discrepancy ‚Üí trigger error-lift if Œ¥ > Œ∫
         * 6. Advance antclock (experiential time, not positional time)
         * 
         * Paper Section 3.4: "The complete CE123 loop at each antclock tick A"
         */
        function evolveStep() {
            if (!isInitialized || currentKernels.length === 0) {
                alert('Create kernels first!');
                return;
            }

            // Advance experiential time (antclock)
            antclock++;
            
            // CE2: First, compute/update edges before evolution using self-referential fractal Sobel
            for (const kernel of currentKernels) {
                if (!kernel.lattice) continue;
                const size = Math.sqrt(kernel.lattice.length);
                
                // Initialize kernel family if first time
                if (!kernel.kernelFamily) {
                    kernel.kernelFamily = null; // Will be created in computeFractalSobelGradients
                    kernel.kernelIteration = 0;
                }
                
                // Use self-referential fractal Sobel for multi-scale edge detection
                // Edges reshape kernels, kernels reshape edges (perceptual fixed-point machine)
                // Pass antclock for drift correction and previous result for convergence checking
                kernel.edges = computeFractalSobelGradients(
                    kernel.lattice, 
                    size, 
                    kernel.kernelFamily,
                    kernel.kernelIteration,
                    antclock, // Pass antclock for timing-based drift correction
                    kernel.edges // Pass previous result for convergence checking
                );
                
                // Update kernel family for next iteration (self-referential evolution)
                if (kernel.edges.updatedKernels) {
                    kernel.kernelFamily = kernel.edges.updatedKernels;
                    kernel.kernelIteration++;
                    
                    if (kernel.edges.converged) {
                        logEntry(`CE2: Kernel family converged to fixed-point (gen ${kernel.kernelIteration})`, 'guardian');
                    } else if (kernel.kernelIteration === 1) {
                        logEntry(`CE2: Self-referential Sobel initialized (scales: 1, 2, 4)`, 'guardian');
                    }
                }
                
                // Store edge history for refinement
                if (!kernel.edgeHistory) kernel.edgeHistory = [];
                kernel.edgeHistory.push({
                    magnitude: new Float32Array(kernel.edges.magnitude),
                    step: antclock,
                    totalEnergy: kernel.edges.totalEnergy,
                    baseEnergy: kernel.edges.baseEnergy,
                    kernelGeneration: kernel.kernelIteration
                });
                // Keep only last 5 steps
                if (kernel.edgeHistory.length > 5) {
                    kernel.edgeHistory.shift();
                }
            }
            
            // CE2: Evolve kernels with edge-preserving dynamics
            // This applies FEG-powered evolution while preserving/refining edges
            for (const kernel of currentKernels) {
                evolveLatticeWithEdgePreservation(kernel);
            }

            // CE2: Refine edges based on evolution changes
            for (const kernel of currentKernels) {
                if (kernel.lattice && kernel.edges) {
                    refineEdges(kernel);
                }
            }

            // CE2: Update guardians (compute guardian metrics from refined edges)
            updateGuardians();

            // CE3: Check for error-lift trigger
            // If discrepancy exceeds threshold Œ∫, trigger grammar evolution
            const discrepancy = computeDiscrepancy();
            if (discrepancy > kappa) {
                triggerErrorLift();
            }

            logEntry(`CE2: Evolution step ${antclock} (A=${antclock})`, 'evolution');
            if (discrepancy > kappa * 0.8) {
                logEntry(`CE3: High discrepancy detected (Œ¥=${discrepancy.toFixed(3)})`, 'guardian');
            }
            
            updateDisplay();
            
            // Update SVG for first kernel (or all if needed)
            if (currentKernels.length > 0) {
                updateRealTimeSVG(currentKernels[0]);
            }
        }

        /**
         * Evolve lattice with edge-preserving dynamics
         * Edges guide evolution: strong edges are preserved, weak edges can be refined
         */
        function evolveLatticeWithEdgePreservation(kernel) {
            const size = Math.sqrt(kernel.lattice.length);
            const currentLattice = kernel.lattice;
            const newLattice = new Float32Array(size * size);
            const edges = kernel.edges;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = y * size + x;

                    // Standard FEG evolution using kernelSystem methods
                    const match = kernelSystem.computeKernelMatch(kernel, currentLattice, x, y, size);
                    const coupling = kernelSystem.computeCouplingSum(kernel, currentLattice, x, y, size);
                    const evolved = kernel.energy * Math.pow(match + coupling, kernel.power);

                    // Edge-preserving modification
                    let edgePreserved = evolved;
                    if (edges && edges.magnitude[idx] > 0.15) {
                        // Strong edge: preserve boundary by maintaining contrast
                        const edgeStrength = edges.magnitude[idx];
                        const neighbors = getNeighborValues(currentLattice, x, y, size);
                        const avgNeighbor = neighbors.reduce((a, b) => a + b, 0) / neighbors.length;
                        
                        // Preserve edge by maintaining difference from neighbors
                        const edgeContrast = Math.abs(currentLattice[idx] - avgNeighbor);
                        edgePreserved = avgNeighbor + (currentLattice[idx] > avgNeighbor ? 1 : -1) * 
                                       Math.max(edgeContrast * 0.7, edgeStrength * 0.3);
                    } else if (edges && edges.magnitude[idx] < 0.05) {
                        // Smooth region: allow more evolution
                        edgePreserved = evolved;
                    } else {
                        // Medium edge: blend evolution with preservation
                        const edgeStrength = edges.magnitude[idx];
                        edgePreserved = evolved * (1 - edgeStrength * 0.3) + currentLattice[idx] * (edgeStrength * 0.3);
                    }

                    newLattice[idx] = Math.max(0, Math.min(1, edgePreserved));
                }
            }

            // Update kernel lattice
            kernel.lattice = newLattice;
            kernelSystem.lattices.set(kernel.id, newLattice);
        }

        /**
         * Get neighbor values for edge preservation
         */
        function getNeighborValues(lattice, x, y, size) {
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = (x + dx + size) % size;
                    const ny = (y + dy + size) % size;
                    neighbors.push(lattice[ny * size + nx]);
                }
            }
            return neighbors;
        }

        /**
         * Refine edges based on evolution changes using fractal Sobel
         * Strong edges that persist across scales and time are reinforced
         * Transient edges are weakened
         */
        function refineEdges(kernel) {
            if (!kernel.edges || kernel.edgeHistory.length < 2) return;

            const size = Math.sqrt(kernel.lattice.length);
            const currentEdges = kernel.edges;
            const previousEdges = kernel.edgeHistory[kernel.edgeHistory.length - 2];

            // Temporal edge refinement: edges that persist are reinforced
            for (let i = 0; i < currentEdges.magnitude.length; i++) {
                const currentMag = currentEdges.magnitude[i];
                const previousMag = previousEdges.magnitude[i];

                // If edge persists across steps, reinforce it
                if (currentMag > 0.1 && previousMag > 0.1) {
                    // Reinforce persistent edges (fractal structure stabilizes)
                    currentEdges.magnitude[i] = Math.min(1.0, currentMag * 1.1);
                } else if (currentMag < 0.05 && previousMag < 0.05) {
                    // Smooth regions stay smooth
                    currentEdges.magnitude[i] = currentMag * 0.9;
                }
                // Transient edges (appear/disappear) are weakened
                else if (Math.abs(currentMag - previousMag) > 0.2) {
                    currentEdges.magnitude[i] = currentMag * 0.8;
                }
            }

            // Recompute self-referential fractal Sobel edges from evolved lattice
            // This continues the perceptual feedback loop
            // Pass antclock for drift correction and previous result for convergence checking
            const refinedEdges = computeFractalSobelGradients(
                kernel.lattice, 
                size, 
                kernel.kernelFamily,
                kernel.kernelIteration,
                antclock, // Antclock timing for drift correction
                kernel.edges // Previous result for convergence checking
            );
            
            // Update kernel family if available
            if (refinedEdges.updatedKernels) {
                kernel.kernelFamily = refinedEdges.updatedKernels;
            }
            
            // Blend: 70% refined (new fractal structure), 30% persistent (old)
            // This maintains fractal coherence while adapting to evolution
            for (let i = 0; i < currentEdges.magnitude.length; i++) {
                currentEdges.magnitude[i] = refinedEdges.magnitude[i] * 0.7 + currentEdges.magnitude[i] * 0.3;
                currentEdges.direction[i] = refinedEdges.direction[i];
            }
            
            // Update energy metrics
            currentEdges.totalEnergy = refinedEdges.totalEnergy;
            currentEdges.baseEnergy = refinedEdges.baseEnergy;
        }

        /**
         * Base Sobel kernels (normalized as invariant "unit directions")
         * Classical 3x3 Sobel operators normalized to act as scale-1 generators
         * K_x(1), K_y(1) - the base seeds for fractal recursion
         */
        function getBaseSobelKernels() {
            // Sobel X kernel (horizontal gradient)
            // [-1  0  1]
            // [-2  0  2]
            // [-1  0  1]
            const sobelX = [
                -1, 0, 1,
                -2, 0, 2,
                -1, 0, 1
            ];
            
            // Sobel Y kernel (vertical gradient)
            // [-1 -2 -1]
            // [ 0  0  0]
            // [ 1  2  1]
            const sobelY = [
                -1, -2, -1,
                 0,  0,  0,
                 1,  2,  1
            ];
            
            // Normalize to unit L¬π norm (sum of absolute values = 1)
            // This makes them invariant "unit directions" for recursion
            const normalize = (kernel) => {
                const sum = kernel.reduce((s, v) => s + Math.abs(v), 0);
                return kernel.map(v => v / sum);
            };
            
            return {
                gx: normalize(sobelX),
                gy: normalize(sobelY),
                size: 3,
                scale: 1 // Base scale-1 generator
            };
        }

        /**
         * Fractal Dilation Rule: D_s expands kernel to scale s
         * Preserves original orientation field without flattening contrast
         * Uses harmonic interpolation for smooth orientation across scales
         * 
         * K(s) = D_s(K(1)) - self-power operator
         */
        function dilateKernel(kernel, scale) {
            if (scale === 1) {
                return {
                    gx: new Float32Array(kernel.gx),
                    gy: new Float32Array(kernel.gy),
                    size: kernel.size,
                    scale: 1
                };
            }
            
            const oldSize = kernel.size;
            // New size: scale the kernel proportionally
            // For scale s, kernel becomes (2s+1) √ó (2s+1) to maintain structure
            const newSize = 2 * scale + 1;
            const dilatedX = new Float32Array(newSize * newSize);
            const dilatedY = new Float32Array(newSize * newSize);
            
            const center = Math.floor(newSize / 2);
            const oldCenter = Math.floor(oldSize / 2);
            
            // Harmonic interpolation: preserves orientation field smoothly
            for (let y = 0; y < newSize; y++) {
                for (let x = 0; x < newSize; x++) {
                    const idx = y * newSize + x;
                    
                    // Map to original kernel space with scaling
                    const dx = (x - center) / scale;
                    const dy = (y - center) / scale;
                    const ox = dx + oldCenter;
                    const oy = dy + oldCenter;
                    
                    // Harmonic interpolation (smooth, orientation-preserving)
                    if (ox >= 0 && ox < oldSize && oy >= 0 && oy < oldSize) {
                        // Direct mapping
                        const oidx = Math.floor(oy) * oldSize + Math.floor(ox);
                        dilatedX[idx] = kernel.gx[oidx];
                        dilatedY[idx] = kernel.gy[oidx];
                    } else {
                        // Harmonic extension: use distance-weighted interpolation
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const angle = Math.atan2(dy, dx);
                        
                        // Project to nearest valid kernel position
                        const nearestX = Math.max(0, Math.min(oldSize - 1, Math.round(ox)));
                        const nearestY = Math.max(0, Math.min(oldSize - 1, Math.round(oy)));
                        const nidx = nearestY * oldSize + nearestX;
                        
                        // Harmonic decay: preserve orientation, attenuate magnitude
                        const harmonicFactor = 1.0 / (1.0 + dist * 0.5);
                        dilatedX[idx] = kernel.gx[nidx] * harmonicFactor;
                        dilatedY[idx] = kernel.gy[nidx] * harmonicFactor;
                    }
                }
            }
            
            return {
                gx: dilatedX,
                gy: dilatedY,
                size: newSize,
                scale: scale
            };
        }

        /**
         * Apply kernel to lattice at position
         */
        function applyKernel(lattice, size, kernel, x, y) {
            const kSize = kernel.size;
            const halfK = Math.floor(kSize / 2);
            let gx = 0, gy = 0;
            
            for (let ky = 0; ky < kSize; ky++) {
                for (let kx = 0; kx < kSize; kx++) {
                    const lx = (x + kx - halfK + size) % size; // Wrap boundary
                    const ly = (y + ky - halfK + size) % size;
                    const lidx = ly * size + lx;
                    const kidx = ky * kSize + kx;
                    
                    gx += lattice[lidx] * kernel.gx[kidx];
                    gy += lattice[lidx] * kernel.gy[kidx];
                }
            }
            
            return {gx, gy};
        }

        /**
         * Self-Referential Fractal Sobel Edge Detection
         * 
         * A perceptual bootloader: edges reshape kernels, kernels reshape edges.
         * The detector becomes a living creature tracing its own silhouette.
         * 
         * CE1 Territory: witness feeds memory, memory feeds morphism, morphism feeds domain.
         * 
         * Properties:
         * 1. Base seeds: K_x(1), K_y(1) as scale-1 generators
         * 2. Fractal dilation: K(s) = D_s(K(1)) with harmonic interpolation
         * 3. Recursive gradient family: E_s = sqrt((I*K_x(s))¬≤ + (I*K_y(s))¬≤)
         * 4. Self-referential feedback: K(s,t+1) = U(K(s,t), E_s(t))
         * 5. Cross-scale coherence: C_s = E_s ¬∑ E_{s/2}
         * 6. Chaos-informed stabilization: logistic map near Feigenbaum point
         * 7. Fixed-point convergence: kernels evolve to coherent internal model
         */
        /**
         * Compute antclock rate R(x) for drift correction
         * Paper Section 3.2.5: R(x) = œá_FEG ¬∑ Œ∫_d(x) ¬∑ (1 + Q_9/11(x))
         */
        function computeAntclockRate(lattice, size, x, y) {
            const chiFEG = 0.638; // Transform quality measure
            const idx = y * size + x;
            const value = lattice[idx];
            
            // Digit count approximation (simplified)
            const digitCount = Math.floor(value * 10);
            const curvature = computePascalCurvature(digitCount);
            
            // Q_9/11 modular correction (simplified)
            const qMod = (digitCount % 11) / 11;
            
            return chiFEG * curvature * (1 + qMod);
        }

        /**
         * Compute Pascal curvature Œ∫_n for digit shell
         */
        function computePascalCurvature(n) {
            if (n < 2) return 0.1;
            // Simplified: r_n = log(binomial(n, floor(n/2)))
            // Œ∫_n = r_{n+1} - 2r_n + r_{n-1}
            const r_n = Math.log(Math.max(1, binomial(n, Math.floor(n/2))));
            const r_np1 = Math.log(Math.max(1, binomial(n+1, Math.floor((n+1)/2))));
            const r_nm1 = Math.log(Math.max(1, binomial(n-1, Math.floor((n-1)/2))));
            return Math.abs(r_np1 - 2*r_n + r_nm1);
        }

        /**
         * Binomial coefficient (simplified)
         */
        function binomial(n, k) {
            if (k > n - k) k = n - k;
            let result = 1;
            for (let i = 0; i < k; i++) {
                result = result * (n - i) / (i + 1);
            }
            return result;
        }

        function computeFractalSobelGradients(lattice, size, previousKernels = null, iteration = 0, antclockTime = 0, previousResult = null) {
            // Use previous kernels if available (self-referential evolution)
            // Otherwise start with base kernels
            let kernelFamily = previousKernels;
            if (!kernelFamily) {
                const baseKernels = getBaseSobelKernels();
                kernelFamily = {
                    base: baseKernels,
                    scales: [1, 2, 4].map(s => ({
                        scale: s,
                        kernel: dilateKernel(baseKernels, s),
                        generation: 0
                    }))
                };
            }
            
            // Extract previous magnitude for convergence checking
            const previousMagnitude = previousResult ? previousResult.magnitude : null;
            
            const scales = kernelFamily.scales.map(s => s.scale);
            
            // Initialize scale responses
            const scaleResponses = kernelFamily.scales.map((scaleData, sIdx) => ({
                scale: scaleData.scale,
                kernel: scaleData.kernel,
                generation: scaleData.generation,
                ex: new Float32Array(size * size), // I * K_x(s)
                ey: new Float32Array(size * size), // I * K_y(s)
                es: new Float32Array(size * size)  // E_s = sqrt(ex¬≤ + ey¬≤)
            }));
            
            // Step 3: Compute recursive gradient family
            // E_s = sqrt((I*K_x(s))¬≤ + (I*K_y(s))¬≤)
            for (let sIdx = 0; sIdx < scaleResponses.length; sIdx++) {
                const response = scaleResponses[sIdx];
                const kernel = response.kernel;
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const idx = y * size + x;
                        const {gx, gy} = applyKernel(lattice, size, kernel, x, y);
                        
                        response.ex[idx] = gx;
                        response.ey[idx] = gy;
                        response.es[idx] = Math.sqrt(gx*gx + gy*gy);
                    }
                }
            }
            
            // Step 4: Renormalized aggregation with stability criterion
            // E = Œ£_s w_s E_s where w_s ~ s^(-Œ±) with Œ± tuned by stability
            // Antclock timing adjusts aggregation to prevent drift
            
            // Compute average antclock rate for drift-aware aggregation
            let avgAntclockRate = 0.638; // Default œá_FEG
            let rateCount = 0;
            const sampleStep = Math.max(4, Math.floor(size / 16));
            for (let y = sampleStep; y < size - sampleStep; y += sampleStep) {
                for (let x = sampleStep; x < size - sampleStep; x += sampleStep) {
                    avgAntclockRate += computeAntclockRate(lattice, size, x, y);
                    rateCount++;
                }
            }
            if (rateCount > 0) avgAntclockRate /= rateCount;
            
            // Drift correction: higher antclock rate = faster time = more aggressive renormalization
            const driftCorrectionFactor = Math.min(1.2, Math.max(0.8, avgAntclockRate / 0.638));
            
            let alpha = 1.0; // Initial power law exponent
            // Adjust base alpha based on antclock rate (faster time = steeper power law)
            alpha *= (1.0 + 0.1 * (driftCorrectionFactor - 1.0));
            let weights = scales.map(s => 1.0 / Math.pow(s, alpha));
            
            // Stability criterion: tune Œ± to avoid runaway amplification
            // Compute total energy at each scale
            const scaleEnergies = scaleResponses.map(r => 
                r.es.reduce((sum, e) => sum + e, 0)
            );
            
            // Check for energy balance: no single scale should dominate
            const maxEnergy = Math.max(...scaleEnergies);
            const minEnergy = Math.min(...scaleEnergies);
            const energyRatio = maxEnergy / (minEnergy + 1e-6);
            
            // Adjust Œ± if energy imbalance detected (stability criterion)
            // Antclock-aware: faster time = more aggressive correction
            if (energyRatio > 3.0) {
                // Increase Œ± to favor smaller scales (more stable)
                alpha = Math.min(1.5, alpha + 0.1 * driftCorrectionFactor);
                weights = scales.map(s => 1.0 / Math.pow(s, alpha));
            } else if (energyRatio < 1.5) {
                // Decrease Œ± to favor larger scales
                alpha = Math.max(0.5, alpha - 0.05 * driftCorrectionFactor);
                weights = scales.map(s => 1.0 / Math.pow(s, alpha));
            }
            
            // Normalize weights to conserve total gradient energy
            const weightSum = weights.reduce((s, w) => s + w, 0);
            weights = weights.map(w => w / weightSum);
            
            // Step 6: Chaos-informed sharpening
            // Modulate sharpening using logistic map near Feigenbaum point
            const feigenbaumMu = 3.56995;
            const logisticMap = (mu, x) => mu * x * (1 - x);
            
            // Initialize chaos state
            // Antclock timing modulates sharpening intensity (faster time = more aggressive)
            let chaosState = 0.5;
            const sharpeningIntensity = 1.0 + 0.2 * (driftCorrectionFactor - 1.0);
            const sharpeningCoeffs = scales.map((s, idx) => {
                chaosState = logisticMap(feigenbaumMu / 4, chaosState);
                // Sharpening coefficient: avoids overshoot, reinforces stable patterns
                // Modulated by antclock drift correction
                return 1.0 + sharpeningIntensity * 0.1 * (chaosState - 0.5);
            });
            
            // Aggregate: E = Œ£_s w_s E_s (with chaos-informed sharpening)
            const magnitude = new Float32Array(size * size);
            const direction = new Float32Array(size * size);
            let totalEnergy = 0;
            let baseEnergy = scaleEnergies[0];
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const idx = y * size + x;
                    
                    let magSum = 0;
                    let dirSumX = 0, dirSumY = 0;
                    
                    for (let sIdx = 0; sIdx < scaleResponses.length; sIdx++) {
                        const response = scaleResponses[sIdx];
                        const w = weights[sIdx];
                        const sharp = sharpeningCoeffs[sIdx];
                        
                        // Weighted, sharpened contribution
                        const contribution = response.es[idx] * w * sharp;
                        magSum += contribution;
                        
                        // Weighted direction
                        dirSumX += response.ex[idx] * w;
                        dirSumY += response.ey[idx] * w;
                    }
                    
                    magnitude[idx] = magSum;
                    direction[idx] = Math.atan2(dirSumY, dirSumX);
                    totalEnergy += magSum;
                }
            }
            
            // Step 5: Cross-scale coupling
            // C_s = E_s ¬∑ E_{s/2} (dot product for coherence)
            for (let sIdx = 1; sIdx < scaleResponses.length; sIdx++) {
                const curr = scaleResponses[sIdx];
                const prev = scaleResponses[sIdx - 1]; // E_{s/2} when s is dyadic
                
                for (let y = 0; y < size; y++) {
                    for (let x = 0; x < size; x++) {
                        const idx = y * size + x;
                        
                        // Dot product: C_s = E_s ¬∑ E_{s/2}
                        // Reveals ridges, boundaries, filaments, scale-consistent structures
                        // Antclock timing modulates coupling strength (faster time = stronger coupling)
                        const crossCoupling = Math.abs(
                            curr.ex[idx] * prev.ex[idx] + 
                            curr.ey[idx] * prev.ey[idx]
                        );
                        
                        // Blend cross-coupling into final map with antclock-modulated strength
                        const couplingStrength = 0.15 * driftCorrectionFactor;
                        magnitude[idx] += crossCoupling * couplingStrength;
                    }
                }
            }
            
            // Step 4 (continued): Renormalization flow
            // Conserve total gradient energy across scales
            const totalEnergyRatio = totalEnergy / (baseEnergy + 1e-6);
            const epsilon = 0.15; // Tolerance for energy conservation
            
            if (Math.abs(totalEnergyRatio - 1.0) > epsilon) {
                // Renormalize to conserve energy (Noether-style invariant)
                const renormalizeFactor = 1.0 / totalEnergyRatio;
                for (let i = 0; i < magnitude.length; i++) {
                    magnitude[i] *= renormalizeFactor;
                }
                totalEnergy *= renormalizeFactor;
            }
            
            // Step 7: Fixed-point requirement
            // Normalize to [0, 1] for stability under iteration
            // Repeated application should converge to fixed point or short periodic orbit
            // Antclock timing adjusts convergence threshold (faster time = tighter threshold)
            let maxMag = 0;
            for (let i = 0; i < magnitude.length; i++) {
                if (magnitude[i] > maxMag) maxMag = magnitude[i];
            }
            
            if (maxMag > 0) {
                // Normalize with stability check
                // Antclock-aware: faster time = more aggressive normalization
                const normalizationFactor = 1.0 / maxMag;
                for (let i = 0; i < magnitude.length; i++) {
                    magnitude[i] = magnitude[i] * normalizationFactor;
                }
            }
            
            // Check convergence against previous result (if available)
            // Antclock-aware convergence threshold
            const convergenceThreshold = 0.01 / driftCorrectionFactor; // Faster time = tighter threshold
            let converged = false;
            let maxChange = 0;
            if (previousMagnitude) {
                for (let i = 0; i < magnitude.length; i++) {
                    const change = Math.abs(magnitude[i] - previousMagnitude[i]);
                    maxChange = Math.max(maxChange, change);
                }
                converged = maxChange < convergenceThreshold;
            }
            
            // Step 4: Self-Referential Feedback Rule
            // K(s,t+1) = U(K(s,t), E_s(t))
            // Update kernels based on edges they detect
            // Use antclock timing for drift correction
            const updatedKernels = updateKernelsSelfReferentially(
                kernelFamily,
                scaleResponses,
                size,
                iteration,
                antclockTime,
                lattice // Pass lattice for antclock rate computation
            );
            
            return {
                magnitude,
                direction,
                maxMagnitude: maxMag,
                scaleEnergies: scaleResponses.map(r => r.es),
                totalEnergy,
                baseEnergy,
                alpha, // Stability-tuned exponent
                weights, // Renormalized weights
                sharpeningCoeffs, // Chaos-informed coefficients
                scaleResponses, // Full multi-scale responses for visualization
                updatedKernels, // Self-referentially evolved kernel family
                converged: converged || updatedKernels.converged, // Fixed-point convergence status
                maxChange: maxChange, // Maximum change from previous iteration
                avgAntclockRate: avgAntclockRate, // Average antclock rate
                driftCorrectionFactor: driftCorrectionFactor // Drift correction applied
            };
        }

        /**
         * Self-Referential Update Map: U(K(s,t), E_s(t))
         * 
         * Updates kernels based on edges they detect:
         * - Feature Attraction: strengthen directions where edges persist
         * - Noise Repulsion: weaken directions with incoherent noise
         * - Energy Invariance: preserve total kernel energy
         * - Smoothness Constraint: preserve differentiability
         * - Antclock Drift Correction: adjust for temporal drift using experiential time
         */
        function updateKernelsSelfReferentially(kernelFamily, scaleResponses, size, iteration, antclockTime, lattice) {
            const feigenbaumMu = 3.56995;
            const epsilon = 0.01; // Convergence threshold
            const updatedScales = [];
            let totalKernelChange = 0;
            let converged = true;
            
            // Compute average antclock rate for drift correction
            // R(x) = œá_FEG ¬∑ Œ∫_d(x) ¬∑ (1 + Q_9/11(x))
            let avgAntclockRate = 0;
            let rateCount = 0;
            const sampleStep = Math.max(4, Math.floor(size / 16));
            for (let y = sampleStep; y < size - sampleStep; y += sampleStep) {
                for (let x = sampleStep; x < size - sampleStep; x += sampleStep) {
                    avgAntclockRate += computeAntclockRate(lattice, size, x, y);
                    rateCount++;
                }
            }
            avgAntclockRate = rateCount > 0 ? avgAntclockRate / rateCount : 0.638; // Default to œá_FEG
            
            // Drift correction factor based on antclock timing
            // Higher antclock rate = faster experiential time = more aggressive drift correction
            const driftCorrectionFactor = Math.min(1.2, Math.max(0.8, avgAntclockRate / 0.638));
            
            for (let sIdx = 0; sIdx < scaleResponses.length; sIdx++) {
                const response = scaleResponses[sIdx];
                const oldKernel = response.kernel;
                const edgeField = response.es;
                const scale = response.scale;
                
                // Compute cross-scale coherence for this scale
                let crossScaleCoherence = null;
                if (sIdx > 0) {
                    const prevResponse = scaleResponses[sIdx - 1];
                    crossScaleCoherence = new Float32Array(size * size);
                    for (let i = 0; i < size * size; i++) {
                        crossScaleCoherence[i] = response.es[i] * prevResponse.es[i];
                    }
                }
                
                // Chaos-informed update intensity modulated by antclock timing
                // Antclock adjusts update rate: faster experiential time = more frequent updates
                const lambda = 0.5 + 0.1 * Math.sin(iteration * 0.1);
                const baseUpdateIntensity = feigenbaumMu * lambda * (1 - lambda);
                
                // Apply antclock drift correction
                // Higher antclock rate means we're experiencing time faster, so adjust updates accordingly
                const updateIntensity = baseUpdateIntensity * driftCorrectionFactor;
                
                // Create updated kernel
                const kSize = oldKernel.size;
                const newKernelX = new Float32Array(oldKernel.gx);
                const newKernelY = new Float32Array(oldKernel.gy);
                
                let kernelChange = 0;
                
                // Update kernel weights based on edge field
                // Sample edge field comprehensively across the image
                for (let ky = 0; ky < kSize; ky++) {
                    for (let kx = 0; kx < kSize; kx++) {
                        const kidx = ky * kSize + kx;
                        
                        // Direction vector of this kernel position
                        const kxDir = kx - Math.floor(kSize / 2);
                        const kyDir = ky - Math.floor(kSize / 2);
                        const kAngle = Math.atan2(kyDir, kxDir);
                        const kMag = Math.sqrt(kxDir*kxDir + kyDir*kyDir);
                        
                        // Sample edge field comprehensively across entire image
                        // Check edge coherence along this kernel direction at multiple positions
                        let edgeCoherence = 0;
                        let edgeCount = 0;
                        const sampleStep = Math.max(2, Math.floor(size / 20)); // Adaptive sampling
                        
                        // Sample at multiple positions across the image
                        for (let sy = sampleStep; sy < size - sampleStep; sy += sampleStep) {
                            for (let sx = sampleStep; sx < size - sampleStep; sx += sampleStep) {
                                // Check edge strength in direction of this kernel element
                                const edgeValue = edgeField[sy * size + sx];
                                
                                // Also check neighbors in the kernel's direction
                                const dirX = Math.cos(kAngle);
                                const dirY = Math.sin(kAngle);
                                const neighborX = Math.floor(sx + dirX * 2);
                                const neighborY = Math.floor(sy + dirY * 2);
                                
                                if (neighborX >= 0 && neighborX < size && neighborY >= 0 && neighborY < size) {
                                    const neighborEdge = edgeField[neighborY * size + neighborX];
                                    // Coherence: edges that persist in this direction
                                    const directionalCoherence = Math.abs(edgeValue - neighborEdge) < 0.1 ? 
                                        (edgeValue + neighborEdge) / 2 : 0;
                                    edgeCoherence += directionalCoherence;
                                    edgeCount++;
                                }
                            }
                        }
                        
                        const avgCoherence = edgeCount > 0 ? edgeCoherence / edgeCount : 0;
                        
                        // Feature Attraction: increase weights where edges persist
                        // Modulated by antclock rate at this position
                        const localAntclockRate = computeAntclockRate(lattice, size, 
                            Math.floor(sx), Math.floor(sy));
                        const localDriftFactor = Math.min(1.2, Math.max(0.8, localAntclockRate / 0.638));
                        
                        const featureAttraction = avgCoherence > 0.2 ? 
                            1.0 + updateIntensity * 0.2 * localDriftFactor : 1.0;
                        
                        // Noise Repulsion: suppress weights with low coherence
                        // Stronger suppression when antclock rate is high (faster time = more aggressive)
                        const noiseRepulsion = avgCoherence < 0.1 ? 
                            1.0 - updateIntensity * 0.1 * localDriftFactor : 1.0;
                        
                        // Cross-scale coherence bonus: C_s = E_s ¬∑ E_{s/2}
                        let crossScaleBonus = 1.0;
                        if (crossScaleCoherence && avgCoherence > 0.15) {
                            // Sample cross-scale coherence in kernel direction
                            let crossCoherence = 0;
                            let crossCount = 0;
                            const sampleStep = Math.max(2, Math.floor(size / 20));
                            
                            for (let sy = sampleStep; sy < size - sampleStep; sy += sampleStep) {
                                for (let sx = sampleStep; sx < size - sampleStep; sx += sampleStep) {
                                    const dirX = Math.cos(kAngle);
                                    const dirY = Math.sin(kAngle);
                                    const neighborX = Math.floor(sx + dirX * 2);
                                    const neighborY = Math.floor(sy + dirY * 2);
                                    
                                    if (neighborX >= 0 && neighborX < size && neighborY >= 0 && neighborY < size) {
                                        const sidx = sy * size + sx;
                                        const nidx = neighborY * size + neighborX;
                                        // Cross-scale dot product: coherence between scales
                                        crossCoherence += crossScaleCoherence[sidx] * crossScaleCoherence[nidx];
                                        crossCount++;
                                    }
                                }
                            }
                            
                            const crossAvg = crossCount > 0 ? crossCoherence / crossCount : 0;
                            crossScaleBonus = 1.0 + updateIntensity * 0.15 * Math.min(crossAvg, 1.0);
                        }
                        
                        // Update kernel weights
                        const oldX = newKernelX[kidx];
                        const oldY = newKernelY[kidx];
                        
                        newKernelX[kidx] *= featureAttraction * noiseRepulsion * crossScaleBonus;
                        newKernelY[kidx] *= featureAttraction * noiseRepulsion * crossScaleBonus;
                        
                        kernelChange += Math.abs(newKernelX[kidx] - oldX) + Math.abs(newKernelY[kidx] - oldY);
                    }
                }
                
                // Energy Invariance: Renormalize to preserve total kernel energy (L¬π norm)
                const oldEnergyX = newKernelX.reduce((s, v) => s + Math.abs(v), 0);
                const oldEnergyY = newKernelY.reduce((s, v) => s + Math.abs(v), 0);
                const newEnergyX = newKernelX.reduce((s, v) => s + Math.abs(v), 0);
                const newEnergyY = newKernelY.reduce((s, v) => s + Math.abs(v), 0);
                
                if (newEnergyX > 0) {
                    const normX = oldEnergyX / newEnergyX;
                    for (let i = 0; i < newKernelX.length; i++) {
                        newKernelX[i] *= normX;
                    }
                }
                if (newEnergyY > 0) {
                    const normY = oldEnergyY / newEnergyY;
                    for (let i = 0; i < newKernelY.length; i++) {
                        newKernelY[i] *= normY;
                    }
                }
                
                // Smoothness Constraint: Apply Gaussian smoothing to preserve differentiability
                smoothKernel(newKernelX, kSize);
                smoothKernel(newKernelY, kSize);
                
                updatedScales.push({
                    scale: scale,
                    kernel: {
                        gx: newKernelX,
                        gy: newKernelY,
                        size: kSize,
                        scale: scale
                    },
                    generation: response.generation + 1
                });
                
                totalKernelChange += kernelChange;
                if (kernelChange > epsilon) {
                    converged = false;
                }
            }
            
            return {
                base: kernelFamily.base,
                scales: updatedScales,
                totalChange: totalKernelChange,
                converged: converged && iteration > 2, // Require multiple iterations
                avgAntclockRate: avgAntclockRate, // Store for display
                driftCorrectionFactor: driftCorrectionFactor
            };
        }

        /**
         * Smooth kernel to preserve differentiability class
         * Applies Gaussian smoothing to maintain smoothness constraint
         */
        function smoothKernel(kernel, kSize) {
            const smoothed = new Float32Array(kernel);
            const sigma = 0.5; // Smoothing radius
            
            for (let y = 0; y < kSize; y++) {
                for (let x = 0; x < kSize; x++) {
                    const idx = y * kSize + x;
                    let sum = 0;
                    let weight = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            
                            if (nx >= 0 && nx < kSize && ny >= 0 && ny < kSize) {
                                const nidx = ny * kSize + nx;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const w = Math.exp(-dist*dist / (2*sigma*sigma));
                                sum += kernel[nidx] * w;
                                weight += w;
                            }
                        }
                    }
                    
                    smoothed[idx] = weight > 0 ? sum / weight : kernel[idx];
                }
            }
            
            // Copy back
            for (let i = 0; i < kernel.length; i++) {
                kernel[i] = smoothed[i];
            }
        }

        /**
         * Test fixed-point stability: apply fractal Sobel iteratively
         * Should converge to fixed point or short periodic orbit
         */
        function testFixedPointStability(lattice, size, maxIterations = 5) {
            let currentLattice = new Float32Array(lattice);
            let previousMagnitude = null;
            let converged = false;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                const edges = computeFractalSobelGradients(currentLattice, size);
                
                if (previousMagnitude) {
                    // Check convergence: magnitude change < threshold
                    let maxDiff = 0;
                    for (let i = 0; i < edges.magnitude.length; i++) {
                        const diff = Math.abs(edges.magnitude[i] - previousMagnitude[i]);
                        if (diff > maxDiff) maxDiff = diff;
                    }
                    
                    if (maxDiff < 0.01) {
                        converged = true;
                        break;
                    }
                }
                
                previousMagnitude = new Float32Array(edges.magnitude);
                
                // Use edges to update lattice (fixed-point iteration)
                // In practice, this would be part of the evolution loop
            }
            
            return {converged, iterations: maxIterations};
        }

        /**
         * Compute Sobel edge detection on lattice (as per paper Section 3.2.2)
         * Now uses fractal Sobel for multi-scale edge detection
         * Guardians detect compositional boundaries analogously to Sobel filters
         */
        function computeSobelGradients(lattice, size) {
            // Use fractal Sobel for richer edge detection
            return computeFractalSobelGradients(lattice, size);
        }

        /**
         * Update guardians using Sobel edge detection on kernel lattices
         * Paper Section 3.2.2: "Guardians detect discontinuities analogously to Sobel filters"
         */
        function updateGuardians() {
            if (currentKernels.length === 0) {
                // No kernels yet, use baseline values
                guardianPhi = 0.85;
                guardianPartial = 0.92;
                guardianScriptR = 0.88;
                return;
            }

            // Compute guardians from lattice edge detection
            let totalPhi = 0, totalPartial = 0, totalScriptR = 0;
            let count = 0;

            for (const kernel of currentKernels) {
                if (!kernel.lattice) continue;

                const size = Math.sqrt(kernel.lattice.length);
                // Use stored fractal edges (refined) if available, otherwise compute fresh
                const sobel = kernel.edges || computeFractalSobelGradients(kernel.lattice, size);

                // œï (Phase Resonance Guardian): Detect semantic discontinuities
                // Measure phase shift (change in semantic direction)
                let phaseVariance = 0;
                let phaseCount = 0;
                for (let i = 0; i < sobel.direction.length; i++) {
                    if (sobel.magnitude[i] > 0.1) {
                        phaseVariance += Math.abs(sobel.direction[i]);
                        phaseCount++;
                    }
                }
                const avgPhaseShift = phaseCount > 0 ? phaseVariance / phaseCount : 0;
                const phi = Math.max(0.3, Math.min(0.98, 1.0 - avgPhaseShift / Math.PI));

                // ‚àÇ (Indentation-Bracket Guardian): Detect structural discontinuities
                // Measure depth discontinuity (gradient magnitude correlates with structural breaks)
                let structuralVariance = 0;
                let structuralCount = 0;
                for (let i = 0; i < sobel.magnitude.length; i++) {
                    if (sobel.magnitude[i] > 0.05) {
                        structuralVariance += sobel.magnitude[i];
                        structuralCount++;
                    }
                }
                // Normalize: high edge density = low structural coherence
                const edgeDensity = structuralCount / sobel.magnitude.length;
                const avgStructuralGradient = structuralCount > 0 ? structuralVariance / structuralCount : 0;
                const partial = Math.max(0.3, Math.min(0.98, 1.0 - (avgStructuralGradient * 0.5 + edgeDensity * 0.5)));

                // ‚Ñõ (Return/Phaselock Guardian): Detect coherence discontinuities
                // Measure preservation ratio (low gradients = high coherence)
                let coherenceSum = 0;
                let coherenceCount = 0;
                let lowGradientCount = 0;
                for (let i = 0; i < sobel.magnitude.length; i++) {
                    const mag = sobel.magnitude[i];
                    coherenceSum += 1.0 - mag;
                    coherenceCount++;
                    if (mag < 0.1) {
                        lowGradientCount++; // Count smooth regions
                    }
                }
                // Coherence = fraction of smooth regions + inverse of average gradient
                const smoothRatio = lowGradientCount / coherenceCount;
                const avgCoherence = coherenceCount > 0 ? coherenceSum / coherenceCount : 0.88;
                const scriptR = Math.max(0.3, Math.min(0.98, (smoothRatio * 0.6 + avgCoherence * 0.4)));

                totalPhi += phi;
                totalPartial += partial;
                totalScriptR += scriptR;
                count++;
            }

            if (count > 0) {
                guardianPhi = totalPhi / count;
                guardianPartial = totalPartial / count;
                guardianScriptR = totalScriptR / count;
            }

            // Phase lock (Theorem 3.2): Maintain coherence when above threshold
            if (guardianScriptR > 0.7) {
                guardianScriptR = Math.max(guardianScriptR, 0.88); // Phaselock maintained
            }
        }

        /**
         * Compute discrepancy (edge strength) from guardian tensor
         * Paper Section 3.2.3: E = ‚àö(Œîœï¬≤ + Œî‚àÇ¬≤ + Œî‚Ñõ¬≤)
         */
        function computeDiscrepancy() {
            if (currentKernels.length === 0) {
                return 0.12; // Baseline when no kernels
            }

            // Edge strength from guardian gradients
            const deltaPhi = 1.0 - guardianPhi;
            const deltaPartial = 1.0 - guardianPartial;
            const deltaScriptR = 1.0 - guardianScriptR;

            const edgeStrength = Math.sqrt(
                deltaPhi * deltaPhi +
                deltaPartial * deltaPartial +
                deltaScriptR * deltaScriptR
            );

            return edgeStrength;
        }

        function triggerErrorLift() {
            const discrepancy = computeDiscrepancy();
            
            if (discrepancy > kappa) {
                errorLiftCount++;
                expressivity += 0.1; // Grammar evolution (Theorem 3.3)
                
                logEntry(`CE3: Error-lift triggered! Œ¥=${discrepancy.toFixed(3)} > Œ∫=${kappa}`, 'error-lift');
                logEntry(`CE3: Grammar evolution. Expressivity E ‚Üí ${expressivity.toFixed(2)}`, 'error-lift');
                
                document.getElementById('ce3-status').textContent = 'EVOLVING';
                document.getElementById('ce3-status').className = 'layer-status status-evolution';
                
                // Reset guardians after error-lift
                setTimeout(() => {
                    guardianPhi = 0.85;
                    guardianPartial = 0.92;
                    guardianScriptR = 0.88;
                    document.getElementById('ce3-status').textContent = 'STABLE';
                    document.getElementById('ce3-status').className = 'layer-status status-active';
                }, 1000);
            }
        }

        function generateWitnessFingerprint(kernel) {
            // 4D signature: (phase Œ∏, depth l, sector s, monodromy m)
            return {
                phase: Math.random() * 2 * Math.PI,
                depth: kernel.discrete.lattice.size / 256,
                sector: Math.floor(Math.random() * 8),
                monodromy: Math.random()
            };
        }

        function addWitnessFingerprint(kernelId, fingerprint) {
            const container = document.getElementById('witness-fingerprints');
            const item = document.createElement('div');
            item.className = 'invariant-item';
            item.innerHTML = `
                <div class="invariant-name">${kernelId}</div>
                <div class="invariant-value">Œ∏=${fingerprint.phase.toFixed(2)}, l=${fingerprint.depth.toFixed(2)}, s=${fingerprint.sector}, m=${fingerprint.monodromy.toFixed(2)}</div>
            `;
            container.appendChild(item);
        }

        let uploadedImage = null;
        let uploadedImageData = null;

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    processUploadedImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processUploadedImage(img) {
            if (!isInitialized) {
                alert('Initialize CE Tower first!');
                return;
            }

            logEntry('Processing uploaded image through CE Tower...', 'evolution');

            // Create canvas to process image
            const processCanvas = document.createElement('canvas');
            const processCtx = processCanvas.getContext('2d');
            const targetSize = 256; // Match lattice size
            processCanvas.width = targetSize;
            processCanvas.height = targetSize;

            // Draw and scale image
            processCtx.drawImage(img, 0, 0, targetSize, targetSize);
            const imageData = processCtx.getImageData(0, 0, targetSize, targetSize);

            // Convert to lattice (grayscale)
            const lattice = new Float32Array(targetSize * targetSize);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const r = imageData.data[i] / 255;
                const g = imageData.data[i + 1] / 255;
                const b = imageData.data[i + 2] / 255;
                const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                lattice[i / 4] = lum;
            }

            // Store for visualization
            uploadedImageData = {imageData, lattice, width: targetSize, height: targetSize};

            // Create kernel from uploaded image
            const kernelId = `uploaded_${Date.now()}`;
            const kernel = {
                id: kernelId,
                energy: 1.0,
                power: 2.0,
                shape: {
                    type: 'image',
                    source: 'uploaded',
                    width: targetSize,
                    height: targetSize
                },
                discrete: {
                    lattice: {
                        size: targetSize,
                        boundary: 'wrap'
                    }
                },
                invariants: [
                    {type: 'scale-invariance', enabled: true},
                    {type: 'rotation-invariance', enabled: false}
                ],
                lattice: lattice,
                isUploaded: true,
                // Store edge information for refinement
                edges: null,
                edgeHistory: []
            };

            kernelSystem.kernels.set(kernelId, kernel);
            kernelSystem.lattices.set(kernelId, lattice);
            currentKernels.push(kernel);

            // Generate witness fingerprint
            const fingerprint = generateWitnessFingerprint(kernel);
            addWitnessFingerprint(kernelId, fingerprint);

            logEntry(`CE1: Created kernel from uploaded image (${img.width}x${img.height})`, 'evolution');
            logEntry('CE2: Computing Sobel edge detection on image lattice...', 'guardian');

            // Update guardians immediately with real edge detection
            updateGuardians();

            updateDisplay();
        }

        function drawCE1Structure() {
            // Draw bracket hierarchy visualization or uploaded image
            const ctx = ce1Ctx;
            const width = ce1Canvas.width;
            const height = ce1Canvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // If we have an uploaded image, show it
            if (uploadedImage) {
                const scale = Math.min(width / uploadedImage.width, height / uploadedImage.height);
                const x = (width - uploadedImage.width * scale) / 2;
                const y = (height - uploadedImage.height * scale) / 2;
                ctx.drawImage(uploadedImage, x, y, uploadedImage.width * scale, uploadedImage.height * scale);
                
                // Overlay operator symbols in corner
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 1;
                ctx.font = '12px monospace';
                ctx.fillStyle = '#4ecdc4';
                ctx.fillText('CE1: Image Kernel', 10, 20);
                return;
            }

            // Draw operator symbols
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.font = '20px monospace';
            ctx.fillStyle = '#4ecdc4';

            // Memory operator []
            ctx.beginPath();
            ctx.moveTo(30, 50);
            ctx.lineTo(20, 50);
            ctx.lineTo(20, 100);
            ctx.lineTo(30, 100);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(50, 50);
            ctx.lineTo(60, 50);
            ctx.lineTo(60, 100);
            ctx.lineTo(50, 100);
            ctx.stroke();
            ctx.fillText('[]', 25, 120);

            // Domain operator {}
            ctx.beginPath();
            ctx.moveTo(100, 50);
            ctx.quadraticCurveTo(90, 50, 90, 75);
            ctx.quadraticCurveTo(90, 100, 100, 100);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(120, 50);
            ctx.quadraticCurveTo(130, 50, 130, 75);
            ctx.quadraticCurveTo(130, 100, 120, 100);
            ctx.stroke();
            ctx.fillText('{}', 95, 120);

            // Transform operator ()
            ctx.beginPath();
            ctx.arc(180, 75, 25, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillText('()', 165, 120);

            // Witness operator <>
            ctx.beginPath();
            ctx.moveTo(230, 50);
            ctx.lineTo(240, 75);
            ctx.lineTo(230, 100);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(260, 50);
            ctx.lineTo(250, 75);
            ctx.lineTo(260, 100);
            ctx.stroke();
            ctx.fillText('<>', 235, 120);
        }

        function drawCE2Flow() {
            const ctx = ce2Ctx;
            const width = ce2Canvas.width;
            const height = ce2Canvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            if (currentKernels.length === 0) return;

            // Draw lattice evolution with Sobel edge overlay
            const kernel = currentKernels[0];
            if (kernel.lattice) {
                const size = Math.sqrt(kernel.lattice.length);
                const scale = width / size;

                // Draw base lattice
                const imageData = ctx.createImageData(width, height);
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const sx = Math.floor(x / scale);
                        const sy = Math.floor(y / scale);
                        if (sx < size && sy < size) {
                            const idx = sy * size + sx;
                            const val = Math.floor(kernel.lattice[idx] * 255);
                            const px = (y * width + x) * 4;
                            imageData.data[px] = 0;
                            imageData.data[px + 1] = val;
                            imageData.data[px + 2] = val * 0.8;
                            imageData.data[px + 3] = 255;
                        }
                    }
                }
                ctx.putImageData(imageData, 0, 0);

                // Overlay fractal Sobel edges (guardian boundaries)
                // Use stored edges if available (refined), otherwise compute fresh
                const sobel = kernel.edges || computeFractalSobelGradients(kernel.lattice, size);
                
                // Draw edges as colored pixels based on magnitude
                const edgeThreshold = 0.1; // Lower threshold to show more edges
                const edgeImageData = ctx.createImageData(width, height);
                
                // Copy base image first
                const baseImageData = ctx.getImageData(0, 0, width, height);
                for (let i = 0; i < baseImageData.data.length; i++) {
                    edgeImageData.data[i] = baseImageData.data[i];
                }
                
                // Overlay edges
                for (let y = 1; y < size - 1; y++) {
                    for (let x = 1; x < size - 1; x++) {
                        const idx = y * size + x;
                        const mag = sobel.magnitude[idx];
                        
                        if (mag > edgeThreshold) {
                            const px = Math.floor(x * scale);
                            const py = Math.floor(y * scale);
                            
                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const pixelIdx = (py * width + px) * 4;
                                
                                // Color edges based on magnitude (red for strong, yellow for weak)
                                const intensity = Math.min(255, mag * 255);
                                edgeImageData.data[pixelIdx] = intensity;     // R
                                edgeImageData.data[pixelIdx + 1] = intensity * 0.3; // G
                                edgeImageData.data[pixelIdx + 2] = 0;        // B
                                edgeImageData.data[pixelIdx + 3] = 255;      // A
                            }
                        }
                    }
                }
                
                ctx.putImageData(edgeImageData, 0, 0);
                
                // Also draw gradient vectors for strong edges
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.4;
                
                const vectorStep = 4; // Draw vectors every N pixels
                for (let y = 1; y < size - 1; y += vectorStep) {
                    for (let x = 1; x < size - 1; x += vectorStep) {
                        const idx = y * size + x;
                        if (sobel.magnitude[idx] > 0.2) { // Only strong edges
                            const px = x * scale;
                            const py = y * scale;
                            const angle = sobel.direction[idx];
                            const len = sobel.magnitude[idx] * 8;
                            
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(
                                px + Math.cos(angle) * len,
                                py + Math.sin(angle) * len
                            );
                            ctx.stroke();
                        }
                    }
                }
                ctx.globalAlpha = 1.0;

                // Label
                ctx.fillStyle = '#45b7d1';
                ctx.font = '12px monospace';
                ctx.fillText('CE2: Self-Referential Fractal Sobel', 10, 20);
                
                // Show kernel evolution generation
                if (kernel.kernelIteration !== undefined) {
                    ctx.fillText(`Gen: ${kernel.kernelIteration}`, 10, 35);
                }
                if (sobel.converged) {
                    ctx.fillStyle = '#4ecdc4';
                    ctx.fillText('FIXED-POINT', 10, 50);
                    ctx.fillStyle = '#45b7d1';
                }
                
                // Show antclock drift correction if available
                if (sobel.updatedKernels && sobel.updatedKernels.avgAntclockRate !== undefined) {
                    ctx.fillText(`R: ${sobel.updatedKernels.avgAntclockRate.toFixed(3)}`, 10, 65);
                    ctx.fillText(`Drift: ${sobel.updatedKernels.driftCorrectionFactor.toFixed(2)}`, 10, 80);
                }
                
                // Show energy conservation and stability metrics if available
                if (sobel.totalEnergy && sobel.baseEnergy) {
                    const energyRatio = (sobel.totalEnergy / (sobel.baseEnergy + 1e-6)).toFixed(2);
                    ctx.fillText(`Energy: ${energyRatio}`, 10, 95);
                }
                if (sobel.alpha !== undefined) {
                    ctx.fillText(`Œ±: ${sobel.alpha.toFixed(2)}`, 10, 110);
                }
                
                // Visualize multi-scale structure: overlay different scale contributions
                if (sobel.scaleResponses && sobel.scaleResponses.length > 0) {
                    ctx.globalAlpha = 0.3;
                    const colors = ['#ff6b6b', '#4ecdc4', '#f9ca24'];
                    for (let sIdx = 0; sIdx < Math.min(sobel.scaleResponses.length, 3); sIdx++) {
                        const response = sobel.scaleResponses[sIdx];
                        ctx.strokeStyle = colors[sIdx];
                        ctx.lineWidth = 1;
                        
                        // Draw strong edges at this scale
                        for (let y = 0; y < size; y += 4) {
                            for (let x = 0; x < size; x += 4) {
                                const idx = y * size + x;
                                if (response.es[idx] > 0.2) {
                                    const px = x * scale;
                                    const py = y * scale;
                                    const angle = Math.atan2(response.ey[idx], response.ex[idx]);
                                    const len = response.es[idx] * 6;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(px, py);
                                    ctx.lineTo(px + Math.cos(angle) * len, py + Math.sin(angle) * len);
                                    ctx.stroke();
                                }
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }
                
                // Show kernel evolution status
                if (kernel.kernelIteration !== undefined && kernel.kernelIteration > 0) {
                    ctx.fillStyle = '#45b7d1';
                    ctx.font = '10px monospace';
                    ctx.fillText(`Kernel Gen: ${kernel.kernelIteration}`, width - 100, height - 10);
                    if (sobel.converged) {
                        ctx.fillStyle = '#4ecdc4';
                        ctx.fillText('FIXED-POINT', width - 100, height - 20);
                    }
                }
            }
        }

        /**
         * Draw CE3: Emergent Simplicial Category
         * 
         * "Simplicial" = geometric structures (triangles, tetrahedra) representing
         * grammatical decompositions. "Emergent" = new structure arises from discrepancies.
         * 
         * Paper Section 3.3: CE3 transforms compositional discrepancies into new
         * grammatical structure via error-lift operator ùîà: Œ¥ ‚Ü¶ new structure
         */
        function drawCE3Evolution() {
            const ctx = ce3Ctx;
            const width = ce3Canvas.width;
            const height = ce3Canvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            const discrepancy = computeDiscrepancy();
            const centerX = width / 2;
            const centerY = height / 2;

            // Draw simplicial triangulation (triangular mesh representing grammatical structure)
            ctx.strokeStyle = '#f9ca24';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;

            // Create triangular mesh - each triangle represents a grammatical decomposition
            const triangleSize = 30;
            const triangles = Math.floor(width / triangleSize);
            
            for (let ty = 0; ty < triangles; ty++) {
                for (let tx = 0; tx < triangles; tx++) {
                    const x = tx * triangleSize;
                    const y = ty * triangleSize;
                    
                    // Draw triangle (simplex)
                    ctx.beginPath();
                    ctx.moveTo(x + triangleSize/2, y);
                    ctx.lineTo(x, y + triangleSize);
                    ctx.lineTo(x + triangleSize, y + triangleSize);
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            // Highlight triangles near discrepancy regions (where error-lift occurs)
            if (discrepancy > kappa * 0.5) {
                ctx.strokeStyle = '#f9ca24';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                
                // Draw highlighted triangles in center region (error-lift zone)
                const highlightSize = Math.min(discrepancy / kappa, 1.0) * 60;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - highlightSize/2);
                ctx.lineTo(centerX - highlightSize/2, centerY + highlightSize/2);
                ctx.lineTo(centerX + highlightSize/2, centerY + highlightSize/2);
                ctx.closePath();
                ctx.stroke();
            }

            ctx.globalAlpha = 1.0;

            // Draw error-lift visualization (discrepancy bar)
            const barWidth = width * Math.min(discrepancy / kappa, 1.0);
            ctx.fillStyle = discrepancy > kappa ? '#f9ca24' : '#333';
            ctx.fillRect(0, height - 30, barWidth, 20);
            ctx.strokeStyle = '#f9ca24';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, height - 30, width, 20);

            // Draw expressivity growth (grammar evolution)
            ctx.strokeStyle = '#f9ca24';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const maxExpressivity = 2.0;
            for (let i = 0; i < width; i++) {
                const x = i;
                const normalizedExp = Math.min(expressivity / maxExpressivity, 1.0);
                const y = height - 60 - normalizedExp * 40;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Label expressivity
            ctx.fillStyle = '#f9ca24';
            ctx.font = '10px monospace';
            ctx.fillText(`E=${expressivity.toFixed(2)}`, 5, height - 65);

            // Draw Œ∂ attractor (recursive identity: self ‚Ü¶ self)
            // This is the fixed point that stabilizes emergent patterns
            const zetaRadius = 8 + (expressivity - 1.0) * 3;
            ctx.fillStyle = '#f9ca24';
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(centerX, centerY, zetaRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw self-reference arrow (Œ∂: self ‚Ü¶ self)
            ctx.strokeStyle = '#f9ca24';
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.8;
            const arrowRadius = zetaRadius + 10;
            ctx.beginPath();
            ctx.arc(centerX, centerY, arrowRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Arrow head pointing back
            ctx.beginPath();
            ctx.moveTo(centerX + arrowRadius, centerY);
            ctx.lineTo(centerX + arrowRadius - 5, centerY - 3);
            ctx.lineTo(centerX + arrowRadius - 5, centerY + 3);
            ctx.closePath();
            ctx.fill();

            ctx.globalAlpha = 1.0;

            // Label
            ctx.fillStyle = '#f9ca24';
            ctx.font = '12px monospace';
            ctx.fillText('CE3: Simplicial Evolution', 10, 20);
            ctx.font = '10px monospace';
            ctx.fillText('Œ∂: self ‚Ü¶ self', centerX - 25, centerY - zetaRadius - 5);
        }

        function drawIntegration() {
            const ctx = integrationCtx;
            const width = integrationCanvas.width;
            const height = integrationCanvas.height;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Draw CE Tower loop
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 80;

            // CE1 ‚Üí CE2 ‚Üí CE3 ‚Üí CE1 loop
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#4ecdc4';
            ctx.font = '16px monospace';
            ctx.fillText('CE1', centerX - 20, centerY - radius - 10);
            ctx.fillStyle = '#45b7d1';
            ctx.fillText('CE2', centerX + radius + 10, centerY);
            ctx.fillStyle = '#f9ca24';
            ctx.fillText('CE3', centerX - 20, centerY + radius + 25);

            // Arrows
            drawArrow(ctx, centerX, centerY - radius, centerX + radius * 0.7, centerY - radius * 0.7, '#4ecdc4');
            drawArrow(ctx, centerX + radius * 0.7, centerY + radius * 0.7, centerX, centerY + radius, '#45b7d1');
            drawArrow(ctx, centerX - radius * 0.7, centerY + radius * 0.7, centerX, centerY - radius, '#f9ca24');
        }

        function drawArrow(ctx, x1, y1, x2, y2, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 10 * Math.cos(angle - Math.PI / 6), y2 - 10 * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 10 * Math.cos(angle + Math.PI / 6), y2 - 10 * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function clearCanvas(ctx, canvas) {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function updateDisplay() {
            // Update metrics
            document.getElementById('bracket-depth').textContent = currentKernels.length > 0 ? '3' : '0';
            document.getElementById('kernel-count').textContent = currentKernels.length;
            document.getElementById('ultrametric').textContent = (1 / Math.pow(2, currentKernels.length)).toFixed(3);
            
            document.getElementById('guardian-phi').textContent = guardianPhi.toFixed(2);
            document.getElementById('guardian-partial').textContent = guardianPartial.toFixed(2);
            document.getElementById('guardian-scriptr').textContent = guardianScriptR.toFixed(2);
            
            document.getElementById('antclock').textContent = antclock;
            document.getElementById('edge-strength').textContent = computeDiscrepancy().toFixed(3);
            
            document.getElementById('discrepancy').textContent = computeDiscrepancy().toFixed(3);
            document.getElementById('error-lifts').textContent = errorLiftCount;
            document.getElementById('expressivity').textContent = expressivity.toFixed(2);
            document.getElementById('zeta-distance').textContent = (0.05 + Math.random() * 0.02).toFixed(3);

            // Redraw visualizations
            drawCE1Structure();
            drawCE2Flow();
            drawCE3Evolution();
            drawIntegration();
        }

        function logEntry(message, type = 'evolution') {
            const log = document.getElementById('evolution-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;

            // Limit log size
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }

        function resetSystem() {
            kernelSystem = null;
            isInitialized = false;
            currentKernels = [];
            antclock = 0;
            errorLiftCount = 0;
            expressivity = 1.0;
            uploadedImage = null;
            uploadedImageData = null;

            // Reset file input
            document.getElementById('image-upload').value = '';

            clearCanvas(ce1Ctx, ce1Canvas);
            clearCanvas(ce2Ctx, ce2Canvas);
            clearCanvas(ce3Ctx, ce3Canvas);
            clearCanvas(integrationCtx, integrationCanvas);

            document.getElementById('evolution-log').innerHTML = '<div class="log-entry">System reset.</div>';
            document.getElementById('witness-fingerprints').innerHTML = '<div class="invariant-item"><div class="invariant-name">No witnesses yet</div><div class="invariant-value">Create kernels to generate 4D signatures</div></div>';

            updateDisplay();
        }

        function showPaperInfo() {
            alert('CE Tower Research Paper\n\nThis interactive exhibit demonstrates the theoretical framework described in:\n\n"CE Tower: Closed-Loop Grammar Evolution for Compositional Learning"\n\nKey concepts visualized:\n- CE1: Discrete Grammar Category (bracket topology)\n- CE2: Dynamical Flow Category (guardian-modulated attention)\n- CE3: Emergent Simplicial Category (error-lift evolution)\n\nSee the paper for complete theoretical foundations.');
        }

        // Kappa slider
        document.getElementById('kappa-slider').addEventListener('input', (e) => {
            kappa = parseFloat(e.target.value);
            document.getElementById('kappa-value').textContent = kappa.toFixed(2);
        });

        // Auto-evolution loop using requestAnimationFrame
        let evolutionAnimationId = null;
        let lastEvolutionTime = 0;
        const evolutionInterval = 50; // ms between evolution steps
        
        function startAutoEvolution() {
            if (evolutionAnimationId) return;
            lastEvolutionTime = performance.now();
            evolutionAnimationId = requestAnimationFrame(evolutionLoop);
        }

        function stopAutoEvolution() {
            if (evolutionAnimationId) {
                cancelAnimationFrame(evolutionAnimationId);
                evolutionAnimationId = null;
            }
        }
        
        function evolutionLoop(currentTime) {
            if (!evolutionAnimationId) return;
            
            if (currentTime - lastEvolutionTime >= evolutionInterval) {
                if (isInitialized && currentKernels.length > 0) {
                    evolveStep();
                }
                lastEvolutionTime = currentTime;
            }
            
            evolutionAnimationId = requestAnimationFrame(evolutionLoop);
        }

        /**
         * Start video capture and real-time processing
         */
        async function startVideoCapture() {
            try {
                // Request camera access
                videoStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });

                // Get UI elements
                videoElement = document.getElementById('video-element');
                videoOverlay = document.getElementById('video-overlay');
                const videoContainer = document.getElementById('video-container');
                const startBtn = document.getElementById('start-video-btn');
                const stopBtn = document.getElementById('stop-video-btn');
                const videoStats = document.getElementById('video-stats');

                // Setup video element
                videoElement.srcObject = videoStream;
                videoElement.play();

                // Setup overlay canvas
                videoOverlay.width = 640;
                videoOverlay.height = 480;

                // Show UI
                videoContainer.style.display = 'block';
                videoStats.style.display = 'grid';
                
                // Reset frame timing
                lastFrameTime = 0;
                frameTimeHistory = [];
                frameCounter = 0;
                lastVideoTime = -1;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                startBtn.classList.remove('active');
                stopBtn.classList.add('active');

                // Auto-show SVG when video starts
                const svgContainer = document.getElementById('ce1-svg-container');
                if (svgContainer) {
                    svgContainer.style.display = 'block';
                    showSVG = true;
                    const toggleBtn = document.getElementById('toggle-svg-btn');
                    if (toggleBtn) {
                        toggleBtn.classList.add('active');
                    }
                }

                // Initialize CE Tower if not already done
                if (!isInitialized) {
                    initializeCETower();
                }

                // Create or get video kernel
                if (!videoKernel) {
                    // Create a kernel from the first frame
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 640;
                    tempCanvas.height = 480;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Wait for first frame
                    videoElement.addEventListener('loadedmetadata', () => {
                        tempCtx.drawImage(videoElement, 0, 0);
                        const imageData = tempCtx.getImageData(0, 0, 640, 480);
                        const lattice = frameToLattice(imageData);
                        videoKernel = createKernelFromLattice(lattice, 'video');
                        currentKernels.push(videoKernel);
                        logEntry('Video kernel created from camera feed', 'evolution');
                    }, { once: true });
                }

                // Start processing loop
                isVideoProcessing = true;
                processVideoFrame();

                logEntry('Video capture started - processing with CE Tower + antclock', 'evolution');

            } catch (error) {
                console.error('Failed to start video capture:', error);
                alert('Failed to access camera. Please check permissions.');
            }
        }

        /**
         * Stop video capture
         */
        function stopVideoCapture() {
            // Reset frame timing
            lastFrameTime = 0;
            frameTimeHistory = [];
            isVideoProcessing = false;

            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }

            const videoContainer = document.getElementById('video-container');
            const startBtn = document.getElementById('start-video-btn');
            const stopBtn = document.getElementById('stop-video-btn');
            const videoStats = document.getElementById('video-stats');

            videoContainer.style.display = 'none';
            videoStats.style.display = 'none';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            startBtn.classList.add('active');
            stopBtn.classList.remove('active');

            // Clear overlay
            if (videoOverlay) {
                const ctx = videoOverlay.getContext('2d');
                ctx.clearRect(0, 0, videoOverlay.width, videoOverlay.height);
            }

            // Hide SVG when video stops
            const svgContainer = document.getElementById('ce1-svg-container');
            if (svgContainer) {
                svgContainer.style.display = 'none';
            }

            logEntry('Video capture stopped', 'evolution');
        }

        /**
         * Toggle SVG display
         */
        function toggleSVGDisplay() {
            showSVG = !showSVG;
            const svgContainer = document.getElementById('ce1-svg-container');
            const toggleBtn = document.getElementById('toggle-svg-btn');
            
            if (svgContainer) {
                svgContainer.style.display = showSVG ? 'block' : 'none';
            }
            
            if (toggleBtn) {
                toggleBtn.classList.toggle('active', showSVG);
            }

            // Update SVG immediately if enabled
            if (showSVG && videoKernel) {
                updateRealTimeSVG(videoKernel);
            }
        }

        /**
         * Process video frame through CE Tower
         */
        function processVideoFrame() {
            if (!isVideoProcessing || !videoElement || !videoOverlay) return;

            // Only process if video has a new frame (currentTime changed)
            const currentVideoTime = videoElement.currentTime;
            if (currentVideoTime === lastVideoTime) {
                // No new frame yet, schedule check again
                requestAnimationFrame(processVideoFrame);
                return;
            }
            lastVideoTime = currentVideoTime;

            const startTime = performance.now();

            try {
                // Capture fresh frame from camera
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 640;
                tempCanvas.height = 480;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(videoElement, 0, 0);

                // Convert to lattice
                const imageData = tempCtx.getImageData(0, 0, 640, 480);
                const lattice = frameToLattice(imageData);

                // Update video kernel lattice with fresh frame
                if (videoKernel) {
                    videoKernel.lattice = lattice;

                    // Process through CE Tower with antclock timing
                    const size = Math.sqrt(lattice.length);
                    
                    // Compute fractal Sobel edges on FRESH frame
                    const freshEdges = computeFractalSobelGradients(
                        lattice,
                        size,
                        videoKernel.kernelFamily,
                        videoKernel.kernelIteration || 0,
                        antclock,
                        null // Don't use previous for convergence - compute fresh
                    );
                    
                    // Merge edge results across frames
                    if (videoKernel.edges) {
                        videoKernel.edges = mergeEdgeResults(videoKernel.edges, freshEdges);
                    } else {
                        videoKernel.edges = freshEdges;
                    }

                    // Update kernel family
                    if (videoKernel.edges.updatedKernels) {
                        videoKernel.kernelFamily = videoKernel.edges.updatedKernels;
                        videoKernel.kernelIteration = (videoKernel.kernelIteration || 0) + 1;
                    }

                    // Evolve lattice with edge preservation
                    if (kernelSystem) {
                        videoKernel.lattice = evolveLatticeWithEdgePreservation(videoKernel);
                    }

                    // Update guardians
                    updateGuardians(videoKernel);

                    // Advance antclock (experiential time)
                    antclock++;

                    // Check for error-lift
                    const discrepancy = computeDiscrepancy();
                    if (discrepancy > kappa) {
                        triggerErrorLift();
                    }

                    // Draw overlay with edges
                    drawVideoOverlay(videoKernel, videoOverlay);

                    // Update main CE Tower visualizations
                    drawCE1Structure();
                    drawCE2Flow();
                    drawCE3Evolution();
                    drawIntegrationLoop();
                    updateDisplay();

                    // Update SVG in real-time (always update when video is processing)
                    // Do this last to ensure all data is ready
                    updateRealTimeSVG(videoKernel);

                    // Update stats
                    frameCounter++;
                    const processingTime = performance.now() - startTime;
                    updateVideoStats(frameCounter, processingTime);
                } else {
                    // Create video kernel if it doesn't exist yet
                    videoKernel = createKernelFromLattice(lattice, 'video');
                    currentKernels.push(videoKernel);
                    logEntry('Video kernel created from camera feed', 'evolution');
                    
                    // Update stats even for first frame
                    frameCounter++;
                    const processingTime = performance.now() - startTime;
                    updateVideoStats(frameCounter, processingTime);
                }

            } catch (error) {
                console.error('Frame processing error:', error);
            }

            // Schedule next frame - ensure loop continues
            if (isVideoProcessing) {
                requestAnimationFrame(processVideoFrame);
            }
        }

        /**
         * Convert image data to lattice
         */
        function frameToLattice(imageData) {
            const { width, height, data } = imageData;
            const latticeSize = 256;
            const lattice = new Float32Array(latticeSize * latticeSize);

            const scaleX = width / latticeSize;
            const scaleY = height / latticeSize;

            for (let y = 0; y < latticeSize; y++) {
                for (let x = 0; x < latticeSize; x++) {
                    const srcX = Math.floor(x * scaleX);
                    const srcY = Math.floor(y * scaleY);
                    const idx = (srcY * width + srcX) * 4;

                    const r = data[idx] / 255;
                    const g = data[idx + 1] / 255;
                    const b = data[idx + 2] / 255;

                    // Convert to luminance
                    const lum = 0.299 * r + 0.587 * g + 0.114 * b;
                    lattice[y * latticeSize + x] = lum;
                }
            }

            return lattice;
        }

        /**
         * Create kernel from lattice
         */
        function createKernelFromLattice(lattice, id) {
            const size = Math.sqrt(lattice.length);
            return {
                id: id || `kernel_${Date.now()}`,
                lattice: lattice,
                size: size,
                edges: null,
                edgeHistory: [],
                kernelFamily: null,
                kernelIteration: 0
            };
        }

        /**
         * Draw video overlay with edge detection
         */
        function drawVideoOverlay(kernel, canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const size = Math.sqrt(kernel.lattice.length);
            const scale = width / size;

            // Clear overlay
            ctx.clearRect(0, 0, width, height);

            if (!kernel.edges) return;

            const edges = kernel.edges;
            const magnitude = edges.magnitude;
            const direction = edges.direction;

            // Draw edges as red pixels with intensity scaling
            ctx.fillStyle = '#ff0000';
            for (let y = 0; y < size; y += 2) {
                for (let x = 0; x < size; x += 2) {
                    const idx = y * size + x;
                    const mag = magnitude[idx];

                    if (mag > 0.2) {
                        const alpha = Math.min(1.0, mag);
                        ctx.globalAlpha = alpha * 0.8;
                        ctx.fillRect(x * scale, y * scale, scale * 2, scale * 2);
                    }
                }
            }
            ctx.globalAlpha = 1.0;

            // Draw gradient vectors for strong edges
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 1;
            for (let y = 0; y < size; y += 8) {
                for (let x = 0; x < size; x += 8) {
                    const idx = y * size + x;
                    const mag = magnitude[idx];

                    if (mag > 0.3) {
                        const angle = direction[idx];
                        const len = mag * 10;
                        const px = x * scale;
                        const py = y * scale;

                        ctx.beginPath();
                        ctx.moveTo(px, py);
                        ctx.lineTo(
                            px + Math.cos(angle) * len,
                            py + Math.sin(angle) * len
                        );
                        ctx.stroke();
                    }
                }
            }

            // Draw antclock rate info
            if (edges.avgAntclockRate !== undefined) {
                ctx.fillStyle = '#4ecdc4';
                ctx.font = '12px monospace';
                ctx.fillText(`A: ${antclock} | R: ${edges.avgAntclockRate.toFixed(3)}`, 10, 20);
            }
        }

        /**
         * Update video statistics display
         */
        function updateVideoStats(frame, processingTime) {
            const now = performance.now();
            
            // Calculate actual FPS from frame timing
            if (lastFrameTime > 0) {
                const frameDelta = now - lastFrameTime;
                frameTimeHistory.push(frameDelta);
                if (frameTimeHistory.length > 30) {
                    frameTimeHistory.shift();
                }
                
                const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
                const fps = avgFrameTime > 0 ? (1000 / avgFrameTime).toFixed(1) : '0';
                document.getElementById('video-fps').textContent = fps;
            } else {
                document.getElementById('video-fps').textContent = '0';
            }
            
            lastFrameTime = now;
            document.getElementById('video-frame').textContent = frame;
            document.getElementById('video-processing').textContent = `${processingTime.toFixed(1)}ms`;
        }

        /**
         * Merge edge detection results across frames
         */
        function mergeEdgeResults(previousEdges, freshEdges) {
            if (!previousEdges || !freshEdges) return freshEdges;
            
            const mergeAlpha = 0.6; // Weight for fresh edges (60% fresh, 40% previous)
            const size = freshEdges.magnitude.length;
            
            // Merge magnitude and direction arrays
            const mergedMagnitude = new Float32Array(size);
            const mergedDirection = new Float32Array(size);
            
            for (let i = 0; i < size; i++) {
                // Merge magnitude: weighted average
                mergedMagnitude[i] = mergeAlpha * freshEdges.magnitude[i] + (1 - mergeAlpha) * previousEdges.magnitude[i];
                
                // Merge direction: weighted circular mean
                const prevAngle = previousEdges.direction[i];
                const freshAngle = freshEdges.direction[i];
                const diff = freshAngle - prevAngle;
                const wrappedDiff = Math.atan2(Math.sin(diff), Math.cos(diff));
                mergedDirection[i] = prevAngle + mergeAlpha * wrappedDiff;
            }
            
            // Preserve all properties from fresh edges, but use merged magnitude/direction
            return {
                magnitude: mergedMagnitude,
                direction: mergedDirection,
                maxMagnitude: Math.max(...Array.from(mergedMagnitude)),
                scaleEnergies: freshEdges.scaleEnergies || [],
                totalEnergy: freshEdges.totalEnergy,
                baseEnergy: freshEdges.baseEnergy,
                alpha: freshEdges.alpha,
                weights: freshEdges.weights || [],
                sharpeningCoeffs: freshEdges.sharpeningCoeffs || [],
                scaleResponses: freshEdges.scaleResponses || [],
                updatedKernels: freshEdges.updatedKernels,
                converged: freshEdges.converged,
                maxChange: freshEdges.maxChange || 0,
                avgAntclockRate: freshEdges.avgAntclockRate || 0,
                driftCorrectionFactor: freshEdges.driftCorrectionFactor || 1.0
            };
        }

        /**
         * Generate real-time SVG from evolved lattice
         */
        function updateRealTimeSVG(kernel) {
            if (!kernel || !kernel.lattice) {
                return; // Silently skip if no data yet
            }

            const svgContainer = document.getElementById('ce1-svg-container');
            const svgDisplay = document.getElementById('ce1-svg-display');
            
            if (!svgContainer || !svgDisplay) {
                return; // Silently skip if containers don't exist
            }

            // Always show container when video is processing
            if (isVideoProcessing) {
                svgContainer.style.display = 'block';
                showSVG = true; // Auto-enable when processing
            }

            const size = Math.sqrt(kernel.lattice.length);
            
            // Validate data
            if (!size || size !== size || size <= 0) {
                return;
            }
            const lattice = kernel.lattice;
            const edges = kernel.edges;

            // Create SVG with viewBox for scaling
            let svg = `<svg width="100%" height="100%" viewBox="0 0 ${size} ${size}" xmlns="http://www.w3.org/2000/svg" style="background: #000;">`;

            // Draw lattice as filled regions (full contour tracing)
            const threshold = 0.3;
            const paths = extractLatticePaths(lattice, size, threshold);
            
            for (const path of paths) {
                svg += `<path d="${path.d}" fill="rgba(78, 205, 196, 0.4)" stroke="#4ecdc4" stroke-width="0.5"/>`;
            }

            // Draw edges as SVG paths (full edge extraction)
            if (edges && edges.magnitude) {
                const edgePaths = extractEdgePaths(edges, size, 0.25);
                for (const path of edgePaths) {
                    svg += `<path d="${path.d}" fill="none" stroke="#ff0000" stroke-width="${path.width}" opacity="${path.opacity}"/>`;
                }

                // Draw gradient vectors as lines
                svg += '<g stroke="#ffff00" stroke-width="0.3" opacity="0.6">';
                for (let y = 0; y < size; y += 8) {
                    for (let x = 0; x < size; x += 8) {
                        const idx = y * size + x;
                        const mag = edges.magnitude[idx];
                        if (mag > 0.3) {
                            const angle = edges.direction[idx];
                            const len = mag * 8;
                            const x2 = x + Math.cos(angle) * len;
                            const y2 = y + Math.sin(angle) * len;
                            svg += `<line x1="${x}" y1="${y}" x2="${x2}" y2="${y2}"/>`;
                        }
                    }
                }
                svg += '</g>';
            }

            // Add antclock info as text
            if (edges && edges.avgAntclockRate !== undefined) {
                svg += `<text x="10" y="20" fill="#4ecdc4" font-size="12" font-family="monospace">A: ${antclock} | R: ${edges.avgAntclockRate.toFixed(3)}</text>`;
            }

            svg += '</svg>';
            
            // Direct update - set innerHTML synchronously
            svgDisplay.innerHTML = svg;
        }


        /**
         * Extract paths from lattice (minimal implementation)
         */
        function extractLatticePaths(lattice, size, threshold) {
            if (kernelSystem && kernelSystem.extractPathsFromLattice) {
                return kernelSystem.extractPathsFromLattice(lattice, size, threshold);
            }
            // Fallback: simple threshold-based regions
            const paths = [];
            const visited = new Set();
            for (let y = 0; y < size - 1; y++) {
                for (let x = 0; x < size - 1; x++) {
                    const idx = y * size + x;
                    if (visited.has(idx) || lattice[idx] < threshold) continue;
                    const contour = traceSimpleContour(lattice, size, x, y, threshold, visited);
                    if (contour.length > 2) {
                        paths.push({d: `M${contour[0].x} ${contour[0].y} ${contour.slice(1).map(p => `L${p.x} ${p.y}`).join(' ')} Z`});
                    }
                }
            }
            return paths;
        }
        
        function traceSimpleContour(lattice, size, startX, startY, threshold, visited) {
            const contour = [];
            let x = startX, y = startY, dir = 0;
            const maxLen = size * 2;
            do {
                const idx = y * size + x;
                if (visited.has(idx) || contour.length > maxLen) break;
                visited.add(idx);
                contour.push({x, y});
                const right = (x + 1 < size) && lattice[y * size + (x + 1)] >= threshold;
                const down = (y + 1 < size) && lattice[(y + 1) * size + x] >= threshold;
                const left = (x - 1 >= 0) && lattice[y * size + (x - 1)] >= threshold;
                const up = (y - 1 >= 0) && lattice[(y - 1) * size + x] >= threshold;
                if (dir === 0 && right) x++;
                else if (dir === 1 && down) y++;
                else if (dir === 2 && left) x--;
                else if (dir === 3 && up) y--;
                else dir = (dir + 1) % 4;
            } while (contour.length < 2 || (x !== startX || y !== startY));
            return contour;
        }

        /**
         * Extract edge paths from edge data
         */
        function extractEdgePaths(edges, size, threshold) {
            const paths = [];
            const visited = new Set();
            const magnitude = edges.magnitude;
            const direction = edges.direction;

            // Find edge segments
            for (let y = 1; y < size - 1; y += 2) {
                for (let x = 1; x < size - 1; x += 2) {
                    const idx = y * size + x;
                    if (visited.has(idx) || magnitude[idx] < threshold) continue;

                    // Trace edge segment
                    const segment = traceEdgeSegment(magnitude, direction, size, x, y, threshold, visited);
                    if (segment.length > 1) {
                        const opacity = Math.min(1.0, magnitude[segment[0].idx] * 2);
                        const width = 0.5 + magnitude[segment[0].idx] * 1.5;
                        paths.push({
                            d: edgeSegmentToSVGPath(segment),
                            opacity: opacity,
                            width: width
                        });
                    }
                }
            }

            return paths;
        }

        /**
         * Trace edge segment following gradient direction
         */
        function traceEdgeSegment(magnitude, direction, size, startX, startY, threshold, visited) {
            const segment = [];
            let x = startX;
            let y = startY;
            const maxLength = 50;

            while (segment.length < maxLength) {
                const idx = y * size + x;
                if (visited.has(idx) || magnitude[idx] < threshold) break;

                visited.add(idx);
                segment.push({x, y, idx});

                // Follow gradient direction
                const angle = direction[idx];
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);

                const nextX = Math.round(x + dx);
                const nextY = Math.round(y + dy);

                if (nextX < 0 || nextX >= size || nextY < 0 || nextY >= size) break;
                if (magnitude[nextY * size + nextX] < threshold) break;

                x = nextX;
                y = nextY;
            }

            return segment;
        }

        /**
         * Convert edge segment to SVG path
         */
        function edgeSegmentToSVGPath(segment) {
            if (segment.length === 0) return '';
            if (segment.length === 1) return `M${segment[0].x} ${segment[0].y}`;

            let path = `M${segment[0].x} ${segment[0].y}`;
            for (let i = 1; i < segment.length; i++) {
                path += ` L${segment[i].x} ${segment[i].y}`;
            }
            return path;
        }

        // Initialize on load
        window.onload = () => {
            updateDisplay();
        };
    </script>
</body>
</html>
