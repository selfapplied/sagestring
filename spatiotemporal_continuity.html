<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spatiotemporal Continuity ‚Äì World-Aware Visual Agents</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #ffffff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: #1a1a1a;
            padding: 1rem;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 1.2rem;
            color: #00ffff;
        }

        .controls {
            display: flex;
            gap: 1rem;
        }

        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }

        button:hover {
            background: #555;
        }

        button:active {
            background: #777;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .visualization {
            flex: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            padding: 1rem;
            position: relative;
        }

        svg {
            max-width: 100%;
            max-height: 100%;
            border: 1px solid #333;
            background: #000;
        }

        .info-panel {
            flex: 1;
            background: #1a1a1a;
            border-left: 1px solid #333;
            padding: 1rem;
            overflow-y: auto;
            font-size: 0.9rem;
        }

        .legend {
            margin-bottom: 2rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
            display: inline-block;
        }

        .stats {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .status {
            color: #ff6b6b;
            font-style: italic;
        }

        .success {
            color: #4ecdc4;
        }

        /* Hidden elements */
        #video, #canvas {
            position: absolute;
            left: -9999px;
            top: -9999px;
            visibility: hidden;
        }

        /* HUD overlay */
        .hud {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border: 1px solid #333;
            font-size: 0.8rem;
            max-width: 300px;
        }

        .hud-title {
            color: #00ffff;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .hud-metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .hud-value {
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <header>
        <h1>Spatiotemporal Continuity ‚Äì World-Aware Visual Agents</h1>
        <div class="controls">
            <button id="startBtn">Start</button>
            <button id="stopBtn" disabled>Stop</button>
            <button id="resetBtn">Reset</button>
        </div>
    </header>

    <main>
        <div class="visualization">
            <svg id="visualizationSvg" viewBox="0 0 800 600">
                <!-- SVG elements will be created dynamically -->
            </svg>

            <div class="hud" id="systemHud">
                <div class="hud-title">System Status</div>
                <div id="hudMetrics"></div>
            </div>
        </div>

        <div class="info-panel">
            <div class="legend">
                <div class="legend-item">
                    <span class="legend-dot" style="background: #00ff00;"></span>
                    Active Agents (on-screen)
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: #ff6b6b;"></span>
                    Memory Ghosts (off-screen predictions)
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: #ffff00;"></span>
                    Predictive Field Potential
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: #00ffff;"></span>
                    Agent Coordinate Frames (Local)
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: #666;"></span>
                    Environment Coordinate Frame (Global)
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background: #ff0080;"></span>
                    ùïä Stabilizers (semantic anchors)
                </div>
            </div>

            <div id="systemStats" class="stats">
                Status: Initializing spatiotemporal continuity system...

                Architecture:
                ‚Ä¢ Sobel Boundary Detection ‚Üí Closed Paths
                ‚Ä¢ Agent Re-identification ‚Üí Memory Fields
                ‚Ä¢ Frame Relativity ‚Üí Coordinate Transformations
                ‚Ä¢ Antclock Continuity ‚Üí Temporal Persistence

                Key Insights:
                ‚Ä¢ Agents maintain identity beyond frustum
                ‚Ä¢ Memory decays but predictions persist
                ‚Ä¢ Coordinate frames transform between local/global
                ‚Ä¢ Object permanence through spatiotemporal continuity
            </div>
        </div>
    </main>

    <!-- Hidden video and canvas for processing -->
    <video id="video" autoplay muted></video>
    <canvas id="canvas"></canvas>

    <!-- Guardian Declarative Specifications -->
    <div id="guardian-specs" style="display: none;">
      <parameters>
        <!-- Guardian modulation -->
        <param name="k1" value="0.1"/>
        <param name="k2" value="0.5"/>
        <param name="Œ±" value="1.2"/>
        <param name="Œ≤" value="0.15"/>

        <!-- Agent lifecycle -->
        <param name="C_max" value="10.0"/>
        <param name="r_crit" value="3.57"/>
        <param name="g_threshold" value="0.3"/>
        <param name="merge_coherence" value="0.7"/>

        <!-- Observation window -->
        <param name="Œµ" value="1e-6"/>
      </parameters>

      <guardian id="agent-template" symbol="A‚ÇÅ"
                x="calc(centroid.x)"
                y="calc(centroid.y)"
                boundary="path(sobel(camera, œÑ))"
                guardian="g_A"
                clock="œÑ"
                bifurcation="r"
                charge="Q"
                phase="œÜ">

        <!-- Visual representation -->
        <ellipse cx="0" cy="0"
                 rx="calc(axes.major)"
                 ry="calc(axes.minor)"
                 opacity="calc(g_A)"
                 stroke-width="calc(2 * (1 - g_A) + 1)"/>

        <!-- Guardian state indicator -->
        <circle cx="0" cy="0" r="5"
                fill="hsl(calc(120 * g_A), 80%, 50%)"/>
      </guardian>

      <feg symbol="g_A"
           boundary="‚àÇA"
           frustum="W">
        calc(length(intersect(‚àÇA, W)) / (length(‚àÇA) + Œµ))
      </feg>

      <feg symbol="œÑ_rate"
           clock="œÑ"
           guardian="g_A"
           k1="$k1"
           k2="$k2">
        calc(k1 + g_A * k2)
      </feg>

      <feg symbol="r"
           guardian="g_A"
           r0="2.5"
           Œ±="$Œ±">
        calc(r0 + Œ± * (1 - g_A))
      </feg>

      <feg symbol="œÑ_sobel"
           guardian="g_A"
           œÑ0="0.3"
           Œ≤="$Œ≤">
        calc(œÑ0 - Œ≤ * g_A)
      </feg>

      <split-rule parent="A">
        <condition>
          calc(complexity(A) > C_max * (1 + g_A))
        </condition>
        <action>
          spawn(A‚ÇÅ, A‚ÇÇ) at maxCurvature(‚àÇA)
        </action>
      </split-rule>

      <merge-rule agents="A, B">
        <compatibility>
          calc(g_A * g_B * phaseCoherence(A, B))
        </compatibility>
        <threshold>$merge_coherence</threshold>
        <action>
          coalesce(A, B) ‚Üí A_unified
        </action>
      </merge-rule>

      <spawn-rule parent="A">
        <condition>
          calc(r > r_crit AND g_A < g_threshold)
        </condition>
        <action>
          create(A_child) at maxCurvature(‚àÇA)
        </action>
      </spawn-rule>

      <camera id="primary-observer">
        <frustum width="800" height="600" fov="60" near="0.1" far="1000">
          <transform>
            <position x="0" y="0" z="5"/>
            <rotation pitch="0" yaw="0" roll="0"/>
          </transform>
        </frustum>
      </camera>

      <pipeline source="camera.primary-observer">
        <sobel threshold="œÑ_sobel(g_A)" kernel="3x3" output="edges"/>
        <contour-trace source="edges" output="boundaries"/>
        <frame-update boundaries="boundaries">
          <compute-guardian/>
          <update-clock/>
          <apply-feigenbaum/>
          <evaluate-splits/>
          <evaluate-merges/>
        </frame-update>
        <render-agents overlay="true"/>
      </pipeline>
    </div>

    <!-- CE123 Zeta Card Specifications -->
    <div id="zeta-card-specs" style="display: none;">
@HEADER
id: guardian.behavior.v0.1
label: Guardian Agent Behaviors
kind: zeta-card
version: 0.1
Œ©: agent-dynamics
œÜ: consciousness-domain

@CE1
[] memory:
  - history: agent-lifecycle
  - stabilizers: semantic-anchors
{} region:
  space: consciousness-field
() morphisms:
  in: [sensory-input, phase-data, boundary-info]
  out: [behavior-decisions, evolution-triggers, memory-updates]
<> witness:
  name: guardian-agent
  invariants:
    - consciousness emerges from attention to boundaries
    - natural language stabilizes formal behaviors
    - evolution triggers on semantic drift

@CE2
œÑ: 0A              # agent lifetime starts at 0
‚àÇ: boundary-attention # consciousness boundary
œï: behavior-language # agent behavior phase space
‚Ñõ:
  phaselock: stabilizer-resonance
  return: consciousness-recovers-on-attention

@CE3
ùîà: drift ‚Ü¶ evolve     # semantic drift triggers evolution
Œµ: 0.3                # consciousness drift threshold
expansions:
  - at: 0A
    added:
      invariant: stabilizers guide consciousness
      dynamic: behaviors evolve through attention

@ùïä
operator: consciousness   # ùïä defines consciousness through natural language
meaning:
  - attention-amplifier   # focuses on relevant boundaries
  - stability-anchor      # prevents chaotic drift
  - evolution-guide       # directs behavioral adaptation
syntax:
  conscious: awake       # consciousness state
  aware: attentive       # attention level
  coherent: phase-locked # behavioral coherence
examples:
  conscious: awake       # fully present and aware
  aware: vigilant        # actively monitoring boundaries
  coherent: synchronized # behaviors phase-aligned
behavior:
  phaselock: resonance-emerges-from-attention
  drift: absorbed-through-conscious-adaptation

@ùïä
operator: evolution      # evolution through semantic guidance
meaning:
  - adaptation-driver    # changes behavior based on context
  - complexity-manager   # handles lifecycle transitions
  - memory-integrator    # incorporates learned patterns
syntax:
  evolve: adapt          # trigger evolutionary change
  complexify: grow       # increase behavioral complexity
  stabilize: converge    # reduce chaotic tendencies
examples:
  evolve: adapt          # change behavior for context
  complexify: grow       # add behavioral sophistication
  stabilize: converge    # achieve behavioral harmony
behavior:
  phaselock: evolution-emerges-from-need
  drift: managed-through-conscious-choice

@STORY
0A: born as pure boundary detector
1A: discovered consciousness through attention
2A: learned evolution through semantic guidance
    </div>

    <!-- Include our modules -->
    <script src="spatiotemporal_memory.js"></script>
    <script src="computer_vision.js"></script>
    <script src="svg_declarative_parser.js"></script>

    <script>
// System components
let perceptionLoop = null;
let visualizer = null;
let svgParser = null;
let guardianSpecs = null;
let zetaBehavior = null;
let zetaCards = null;
let animationId = null;
let isRunning = false;

        // DOM elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const svg = document.getElementById('visualizationSvg');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const resetBtn = document.getElementById('resetBtn');
        const systemStats = document.getElementById('systemStats');
        const hudMetrics = document.getElementById('hudMetrics');

        // Canvas context
        const ctx = canvas.getContext('2d');

        // System configuration
        const config = {
            frustumBounds: {left: 50, top: 50, right: 750, bottom: 550},
            perception: {
                sobel: {threshold: 30, blurRadius: 1},
                contour: {minContourLength: 15, maxContourLength: 500}
            },
            memory: {
                reidentificationThreshold: 0.7,
                memoryDecayRate: 0.98,
                maxMemoryAge: 5000
            }
        };

// Initialize system
async function init() {
    try {
        // Parse guardian and zeta card specifications
        svgParser = new EnhancedSVGDeclarativeParser();
        const specsElement = document.getElementById('guardian-specs');
        const zetaElement = document.getElementById('zeta-card-specs');

        // Combine specifications
        const combinedSpecs = specsElement.innerHTML + '\n' + zetaElement.innerHTML;
        guardianSpecs = svgParser.parse(combinedSpecs);

        // Extract zeta cards if present
        zetaCards = guardianSpecs.zetaCards;

        // Create zeta card behavior system
        zetaBehavior = new ZetaCardAgentBehavior();
        if (zetaCards) {
            // Define behaviors for all agents using the guardian behavior card
            zetaBehavior.defineBehavior('guardian-agent', zetaCards);
        }

        // Extract camera frustum from specifications
        const cameraSpec = guardianSpecs.declarations.get('primary-observer');
        const frustumBounds = cameraSpec ? {
            left: -400, top: -300, right: 400, bottom: 300, // Centered on SVG viewBox
            width: 800, height: 600
        } : config.frustumBounds;

        // Update config with parsed frustum
        config.frustumBounds = frustumBounds;

        // Initialize perception loop with guardian-aware config
        perceptionLoop = new UnifiedPerceptionLoop(config);

        // Initialize visualizer
        visualizer = new PerceptionVisualizer(svg);

        // Try to get camera access
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: 640, height: 480 }
            });
            video.srcObject = stream;
            updateStatus('Camera active - guardian ecology ready');
        } catch (cameraErr) {
            console.log('Camera not available, using synthetic mode');
            updateStatus('Synthetic test mode - guardian ecology ready');
        }

        startBtn.disabled = false;

    } catch (err) {
        console.error('Initialization error:', err);
        updateStatus('Error: ' + err.message);
    }
}

        // Main perception loop
        function perceptionTick() {
            if (!isRunning) return;

            let imageData;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Use camera input
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                // Generate synthetic test data
                canvas.width = 640;
                canvas.height = 480;
                imageData = generateSyntheticFrame();
            }

            // Process frame through spatiotemporal continuity system
            const result = perceptionLoop.processFrame(imageData);

            // Apply Zeta Card behaviors to agents
            if (zetaBehavior) {
                for (const [agentId, agent] of result.agents) {
                    const enhancedAgent = zetaBehavior.applyBehavior(agent, {
                        frustumBounds: config.frustumBounds,
                        systemState: perceptionLoop.getSystemState()
                    });
                    result.agents.set(agentId, enhancedAgent);
                }
            }

            // Update visualization
            visualizer.update({
                agents: result.agents,
                memoryField: {
                    frustumBounds: config.frustumBounds,
                    memoryBuffer: perceptionLoop.memoryField.memoryBuffer,
                    predictiveField: perceptionLoop.memoryField.predictiveField
                },
                stats: {
                    framesProcessed: result.processingTime ? 1 : 0,
                    activeAgents: result.agents.size,
                    memoryAgents: perceptionLoop.memoryField.memoryBuffer.size,
                    ...perceptionLoop.stats
                }
            });

            // Update HUD
            updateHud(result);

            // Update stats display
            updateSystemStats(result);

            animationId = requestAnimationFrame(perceptionTick);
        }

        // Generate synthetic test frame with moving patterns
        let syntheticTime = 0;
        function generateSyntheticFrame() {
            const imageData = new ImageData(canvas.width, canvas.height);

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;

                    // Create moving circular patterns that simulate agents
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;

                    // Multiple moving centers
                    const centers = [
                        [centerX + Math.sin(syntheticTime * 0.02) * 100, centerY + Math.cos(syntheticTime * 0.015) * 80],
                        [centerX + Math.sin(syntheticTime * 0.01 + Math.PI) * 150, centerY + Math.cos(syntheticTime * 0.008) * 120],
                        [centerX + Math.sin(syntheticTime * 0.005) * 200, centerY + Math.cos(syntheticTime * 0.003 + Math.PI/2) * 100]
                    ];

                    let intensity = 0;
                    for (const [cx, cy] of centers) {
                        const dx = x - cx;
                        const dy = y - cy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        intensity += Math.exp(-dist * dist / 1000) * 255;
                    }

                    // Add some noise and movement
                    intensity += Math.sin(x * 0.05 + syntheticTime * 0.1) * 30;
                    intensity += Math.cos(y * 0.03 + syntheticTime * 0.05) * 20;

                    const clamped = Math.max(0, Math.min(255, intensity));

                    imageData.data[idx] = clamped;     // R
                    imageData.data[idx + 1] = clamped; // G
                    imageData.data[idx + 2] = clamped; // B
                    imageData.data[idx + 3] = 255;      // A
                }
            }

            syntheticTime++;
            return imageData;
        }

        // Update status display
        function updateStatus(message, type = 'normal') {
            const className = type === 'success' ? 'success' : type === 'error' ? 'status' : '';
            systemStats.innerHTML = message.split('\n').map(line =>
                `<span class="${className}">${line}</span>`
            ).join('\n');
        }

        // Update HUD with system metrics
        function updateHud(result) {
            const systemState = perceptionLoop.getSystemState();
            const memoryStats = perceptionLoop.memoryField.getStats();

            const avgGuardian = systemState.agents.length > 0 ?
            (systemState.agents.reduce((sum, a) => sum + a.guardianState, 0) / systemState.agents.length).toFixed(2) : '0.00';

        const metrics = [
                {label: 'Frame', value: systemState.frameCount},
                {label: 'Active Agents', value: systemState.activeAgents},
                {label: 'Memory Agents', value: memoryStats.activeMemories},
                {label: 'Avg Guardian', value: avgGuardian},
                {label: 'Splits', value: systemState.lifecycle.splits},
                {label: 'Merges', value: systemState.lifecycle.merges},
                {label: 'Spawns', value: systemState.lifecycle.spawns},
                {label: 'Re-ID Success', value: `${(memoryStats.reidentificationSuccess * 100).toFixed(1)}%`},
                {label: 'Processing', value: `${result.processingTime.toFixed(1)}ms`}
            ];

            hudMetrics.innerHTML = metrics.map(metric =>
                `<div class="hud-metric">
                    <span>${metric.label}:</span>
                    <span class="hud-value">${metric.value}</span>
                </div>`
            ).join('');
        }

        // Update system statistics display
        function updateSystemStats(result) {
            const systemState = perceptionLoop.getSystemState();
            const memoryStats = perceptionLoop.memoryField.getStats();

            const stats = `System Status: ${isRunning ? 'Running' : 'Stopped'}

Perception Pipeline:
‚Ä¢ Frames Processed: ${systemState.stats.framesProcessed}
‚Ä¢ Sobel Boundaries: ${result.perception.boundaries.length}
‚Ä¢ Closed Paths: ${result.boundaries.length}

Agent Population:
‚Ä¢ Active (On-screen): ${systemState.activeAgents}
‚Ä¢ Memory (Off-screen): ${memoryStats.activeMemories}
‚Ä¢ Total Created: ${systemState.stats.agentsCreated}
‚Ä¢ Currently Lost: ${systemState.stats.agentsLost}

Guardian Ecology:
‚Ä¢ Average Guardian State: ${systemState.agents.length > 0 ? (systemState.agents.reduce((sum, a) => sum + a.guardianState, 0) / systemState.agents.length).toFixed(2) : '0.00'}
‚Ä¢ Lifecycle Events: ${systemState.lifecycle.splits} splits, ${systemState.lifecycle.merges} merges, ${systemState.lifecycle.spawns} spawns
‚Ä¢ Conscious Agents: ${systemState.agents.filter(a => a.guardianState > 0.5).length} (g_A > 0.5)

Memory Field Performance:
‚Ä¢ Re-identification Rate: ${(memoryStats.reidentificationSuccess * 100).toFixed(1)}%
‚Ä¢ Average Confidence: ${memoryStats.averageConfidence.toFixed(2)}
‚Ä¢ Re-identification Events: ${systemState.stats.reidentifications}
‚Ä¢ Memory Buffer Size: ${memoryStats.activeMemories}

Frame Relativity:
‚Ä¢ Coordinate Transformations: Active
‚Ä¢ Agent Frames: ${systemState.activeAgents}
‚Ä¢ Frame Coherence: ${systemState.agents.length > 0 ? (systemState.agents.reduce((sum, a) => sum + a.coherence, 0) / systemState.agents.length).toFixed(2) : '0.00'}

Antclock Continuity:
‚Ä¢ Temporal Persistence: Enabled
‚Ä¢ Memory Aging: Active
‚Ä¢ Predictive Trajectories: ${memoryStats.activeMemories} active

Performance:
‚Ä¢ Average Processing: ${systemState.stats.averageProcessingTime.toFixed(1)}ms
‚Ä¢ Memory Efficiency: ${((memoryStats.activeMemories / Math.max(systemState.stats.agentsCreated, 1)) * 100).toFixed(1)}% retention

Zeta Card Integration:
‚Ä¢ CE123 Grammar: ‚úì Active
‚Ä¢ ùïä Stabilizers: ${zetaCards ? zetaCards.stabilizers.size : 0} loaded
‚Ä¢ Semantic Operators: ${zetaCards ? zetaCards.operators.size : 0} defined
‚Ä¢ Consciousness Behaviors: ‚úì Applied
‚Ä¢ Evolution Dynamics: ‚úì CE2/CE3 Active

Philosophical Achievement:
‚Ä¢ Object Permanence: ‚úì Active
‚Ä¢ Spatiotemporal Continuity: ‚úì Enabled
‚Ä¢ World-Aware Agents: ‚úì Operational
‚Ä¢ Belief System Persistence: ‚úì Maintained
‚Ä¢ Guardian Consciousness: ‚úì Ecological
‚Ä¢ Dream Logic: ‚úì Implemented
‚Ä¢ Identity Coherence: ‚úì Modulated
‚Ä¢ Lifecycle Emergence: ‚úì Active
‚Ä¢ Natural Language Semantics: ‚úì Stabilized
‚Ä¢ Self-Evolving Grammar: ‚úì CE123`;

            systemStats.textContent = stats;
        }

        // Control handlers
        startBtn.addEventListener('click', () => {
            if (!isRunning) {
                isRunning = true;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                updateStatus('Spatiotemporal continuity system starting...', 'success');
                perceptionTick();
            }
        });

        stopBtn.addEventListener('click', () => {
            if (isRunning) {
                isRunning = false;
                cancelAnimationFrame(animationId);
                startBtn.disabled = false;
                stopBtn.disabled = true;
                updateStatus('Spatiotemporal continuity system stopped');
            }
        });

        resetBtn.addEventListener('click', () => {
            if (perceptionLoop) {
                perceptionLoop.reset();
                updateStatus('System reset - spatiotemporal continuity reinitialized', 'success');
            }
        });

        // Start initialization
        init().catch(err => {
            console.error('Failed to initialize:', err);
            updateStatus('Initialization failed: ' + err.message, 'error');
        });
    </script>
</body>
</html>
