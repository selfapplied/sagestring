<!DOCTYPE html>
<html>
<head>
    <title>SVG Kernel Mirror: Self-Reflective Pattern Recognition</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            margin: 20px;
        }
        .main-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .main-display {
            grid-column: 1 / -1;
        }
        .panel {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 8px;
        }
        .kernel-display {
            width: 100%;
            height: 400px;
            background: #000;
            border: 1px solid #444;
        }
        .lattice-viz {
            width: 100%;
            height: 256px;
            background: #000;
            border: 1px solid #444;
            image-rendering: pixelated;
        }
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        button {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 8px 16px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #3a3a3a;
        }
        .status {
            font-size: 12px;
            color: #888;
            margin-top: 10px;
            text-align: center;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>SVG Kernel Mirror</h1>

    <div class="main-container">
        <div class="panel main-display">
            <h3>Evolved SVG</h3>
            <div class="kernel-display" id="reflected-svg"></div>
        </div>

        <div class="panel">
            <h3>Lattice</h3>
            <canvas class="lattice-viz" id="evolved-lattice-2" width="256" height="256"></canvas>
        </div>

        <div class="panel">
            <h3>Original</h3>
            <div class="kernel-display" id="original-kernel"></div>
        </div>
    </div>

    <div class="controls">
        <button onclick="initializeSystem()">Initialize Kernel</button>
        <button onclick="discretizeKernel()">Discretize to Lattice</button>
        <button onclick="evolveStep()">Evolve One Step</button>
        <button onclick="evolveMultiple(5)">Evolve 5 Steps</button>
        <button onclick="vectorizeBack()">Vectorize to SVG</button>
        <button onclick="runFullCycle()">Run Full Cycle</button>
        <button id="live-update-btn" onclick="toggleLiveUpdate()">Animate</button>
        <button onclick="resetSystem()">Reset</button>
    </div>

    <div class="status" id="status">Ready to initialize...</div>

    <script src="livecam/svg_kernel_system.js"></script>
    <script>
        let kernelSystem;
        let currentKernelId = 'spiral';
        let liveUpdateActive = false;
        let animationFrameId = null;
        let lastUpdateTime = 0;
        const updateInterval = 50;

        // Sample kernel definitions
        const kernelDefinitions = {
            spiral: `<kernel id="spiral" energy="1.2" power="2.0">
  <shape>
    <path d="M128 128 L128 108 A20 20 0 0 1 148 128 L168 128 A40 40 0 0 0 128 168 L128 188 A60 60 0 0 1 68 128 L48 128 A80 80 0 0 0 128 48 Z"
          stroke="#00ff88" stroke-width="3" fill="none"/>
  </shape>
  <discrete>
    <lattice size="256" boundary="wrap"/>
  </discrete>
  <invariants>
    <scale-invariance enabled="true"/>
    <mirror-symmetry enabled="true"/>
  </invariants>
</kernel>`,

            wave: `<kernel id="wave" energy="1.0" power="1.8">
  <shape>
    <path d="M0 128 Q64 64 128 128 T256 128"
          stroke="#0088ff" stroke-width="4" fill="none"/>
  </shape>
  <discrete>
    <lattice size="256" boundary="wrap"/>
  </discrete>
  <invariants>
    <scale-invariance enabled="true"/>
  </invariants>
</kernel>`,

            circle: `<kernel id="circle" energy="1.5" power="2.2">
  <shape>
    <circle cx="128" cy="128" r="60" stroke="#ff8800" stroke-width="4" fill="none"/>
  </shape>
  <discrete>
    <lattice size="256" boundary="wrap"/>
  </discrete>
  <invariants>
    <scale-invariance enabled="true"/>
    <rotation-invariance enabled="true"/>
  </invariants>
</kernel>`
        };

        function initializeSystem() {
            kernelSystem = new SVGKernelSystem();

            // Parse kernel
            const kernels = kernelSystem.parseKernel(kernelDefinitions.spiral);
            updateStatus(`Initialized: ${kernels[0].id}`);

            // Display original SVG
            displayOriginalKernel();
        }

        function displayOriginalKernel() {
            const container = document.getElementById('original-kernel');
            const svgContent = kernelDefinitions.spiral.replace('<kernel', '<svg').replace('</kernel>', '</svg>');
            container.innerHTML = svgContent.replace('width="256"', 'width="100%"').replace('height="256"', 'height="100%"');
        }

        function discretizeKernel() {
            if (!kernelSystem) {
                updateStatus("Initialize first");
                return;
            }

            kernelSystem.discretizeKernel(kernelSystem.kernels.get(currentKernelId));
            updateStatus("Discretized");
            const kernel = kernelSystem.kernels.get(currentKernelId);
            visualizeLattice('evolved-lattice-2', kernel.lattice);
            updateSVGDisplay();
        }

        function evolveStep() {
            if (!kernelSystem) return;

            const evolved = kernelSystem.evolveLattice(currentKernelId);
            if (evolved) {
                updateStatus("Evolved");
                visualizeLattice('evolved-lattice-2', evolved);
                updateSVGDisplay();
            }
        }

        function evolveMultiple(steps) {
            if (!kernelSystem) return;

            for (let i = 0; i < steps; i++) {
                kernelSystem.evolveLattice(currentKernelId);
            }
            updateStatus(`Evolved ${steps} steps`);
            const kernel = kernelSystem.kernels.get(currentKernelId);
            visualizeLattice('evolved-lattice-2', kernel.lattice);
            updateSVGDisplay();
        }

        function vectorizeBack() {
            if (!kernelSystem) return;

            const svgString = kernelSystem.latticeToSVG(currentKernelId);
            if (svgString) {
                document.getElementById('reflected-svg').innerHTML = svgString;
                updateStatus("Lattice vectorized back to SVG");
            }
        }

        function updateSVGDisplay() {
            if (!kernelSystem) return;

            const kernel = kernelSystem.kernels.get(currentKernelId);
            if (!kernel || !kernel.lattice) return;

            const svgString = kernelSystem.latticeToSVG(currentKernelId);
            if (svgString) {
                const scaledSvg = svgString.replace('width="256"', 'width="100%"').replace('height="256"', 'height="100%"');
                document.getElementById('reflected-svg').innerHTML = scaledSvg;
            }
        }

        function toggleLiveUpdate() {
            if (!kernelSystem) {
                updateStatus("Initialize and discretize kernel first!");
                return;
            }

            const kernel = kernelSystem.kernels.get(currentKernelId);
            if (!kernel || !kernel.lattice) {
                updateStatus("Discretize kernel first!");
                return;
            }

            liveUpdateActive = !liveUpdateActive;
            const btn = document.getElementById('live-update-btn');
            
            if (liveUpdateActive) {
                btn.textContent = 'Stop';
                btn.style.background = '#4a2a2a';
                lastUpdateTime = performance.now();
                animationFrameId = requestAnimationFrame(liveUpdateLoop);
                updateStatus("Animating");
            } else {
                btn.textContent = 'Animate';
                btn.style.background = '#2a2a2a';
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                updateStatus("Stopped");
            }
        }

        function liveUpdateLoop(currentTime) {
            if (!liveUpdateActive || !kernelSystem) {
                return;
            }

            if (currentTime - lastUpdateTime >= updateInterval) {
                const kernel = kernelSystem.kernels.get(currentKernelId);
                if (kernel && kernel.lattice) {
                    kernelSystem.evolveLattice(currentKernelId);
                    updateSVGDisplay();
                    lastUpdateTime = currentTime;
                }
            }

            animationFrameId = requestAnimationFrame(liveUpdateLoop);
        }

        function runFullCycle() {
            initializeSystem();
            setTimeout(() => {
                discretizeKernel();
                setTimeout(() => {
                    evolveMultiple(3);
                    setTimeout(() => {
                        vectorizeBack();
                        updateStatus("Full cycle completed: SVG → Lattice → Evolution → SVG");
                    }, 100);
                }, 100);
            }, 100);
        }

        function resetSystem() {
            if (liveUpdateActive) {
                toggleLiveUpdate();
            }
            kernelSystem = null;
            document.getElementById('original-kernel').innerHTML = '';
            clearCanvases();
            updateStatus("Reset");
        }

        function visualizeLattice(canvasId, lattice) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const size = Math.sqrt(lattice.length);
            const imageData = ctx.createImageData(size, size);

            for (let i = 0; i < lattice.length; i++) {
                const val = Math.floor(lattice[i] * 255);
                imageData.data[i * 4] = val;     // R
                imageData.data[i * 4 + 1] = val; // G
                imageData.data[i * 4 + 2] = val; // B
                imageData.data[i * 4 + 3] = 255; // A
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function clearCanvases() {
            const canvas = document.getElementById('evolved-lattice-2');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            document.getElementById('reflected-svg').innerHTML = '';
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // Initialize on load
        window.onload = () => {
            updateStatus("Ready");
        };
    </script>
</body>
</html>


