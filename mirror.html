<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AntClock Live Mirror</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: monospace;
            background: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        .window {
            flex: 1;
            border: 1px solid #333;
            position: relative;
            overflow: hidden;
        }
        #input {
            background: #111;
        }
        #output {
            background: #000;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        canvas {
            display: none;
        }
        .status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            font-size: 11px;
            z-index: 10;
            border: 1px solid #444;
        }
        #antclock-hud {
            pointer-events: none;
        }
        :root {
            --phase-angle: 0;
            --mirror-phase: 0;
            --curvature-value: 0;
            --bifurcation-index: 0;
            --q911-value: 0;
        }
    </style>
</head>
<body>
    <!-- 1. Video Input -->
    <div class="window" id="input">
        <video id="feed" autoplay playsinline></video>
        <div class="status" id="inputStatus">Initializing camera...</div>
    </div>

    <!-- 2. Hidden Canvas for Analysis -->
    <canvas id="analyzer" width="320" height="240"></canvas>

    <!-- 3. AntClock Declarative Visualization -->
    <div class="window" id="output">
        <svg id="mirror" xmlns="http://www.w3.org/2000/svg">
            <!-- AntClock Declarative Operators (drive visualization via CSS custom properties) -->
            <antclock id="antclock-walker" symbol="walker" x="1" chiFeg="0.638"/>
            <antclock id="antclock-curvature" symbol="curvature" n="1" string="0"/>
            <antclock id="antclock-phase" symbol="phase" angle="0" mirrorPhase="0"/>
            <antclock id="antclock-shell" symbol="shell" digitCount="1" bifurcationIndex="0"/>
            <antclock id="antclock-charge" symbol="charge" q911="0" mirrorOperator="0"/>
            <antclock id="antclock-corridor" symbol="corridor" start="0" end="0" monodromy="0"/>

            <!-- AntClock Geometry (driven by declarative operators) -->
            <g id="antclock-geometry">
                <!-- Unit circle representing the phase space -->
                <circle id="unit-circle" cx="50%" cy="50%" r="150"
                        stroke="#333" stroke-width="2" fill="none" opacity="0.3"/>

                <!-- Phase angle indicator (rotates with walker) -->
                <circle id="phase-indicator" cx="50%" cy="50%" r="140"
                        stroke="none" fill="hsl(calc(var(--phase-angle) * 57.3), 70%, 50%)"
                        opacity="0.8"
                        transform="rotate(calc(var(--phase-angle) * 57.3) 50% 50%)"/>

                <!-- Curvature field (expands/contracts with curvature) -->
                <circle id="curvature-field" cx="50%" cy="50%"
                        r="calc(80 + var(--curvature-value) * 40)"
                        stroke="hsl(calc(240 + var(--curvature-value) * 120), 60%, 60%)"
                        stroke-width="calc(1 + var(--curvature-value) * 3)"
                        fill="none"
                        opacity="calc(0.3 + var(--curvature-value) * 0.4)"/>

                <!-- Walker trajectory (spiral path) -->
                <path id="walker-path" d="" stroke="#4ecdc4" stroke-width="2" fill="none" opacity="0.7"/>
            </g>

            <!-- AntClock HUD (declarative state display) -->
            <g id="antclock-hud" transform="translate(60, 60)">
                <!-- Clock phase ring -->
                <circle id="clock-ring"
                        cx="0" cy="0"
                        r="30"
                        stroke="#4ecdc4"
                        stroke-width="3"
                        fill="none"
                        opacity="0.8"
                        stroke-dasharray="calc(20 + var(--phase-angle) * 10)"
                        transform="rotate(calc(var(--phase-angle) * 57.3))"/>

                <!-- Mirror phase indicator -->
                <circle id="mirror-indicator"
                        cx="0" cy="0"
                        r="calc(8 + var(--mirror-phase) * 8)"
                        fill="hsl(calc(30 + var(--mirror-phase) * 30), 80%, 60%)"
                        opacity="0.9"/>

                <!-- Bifurcation index bar -->
                <rect id="bifurcation-bar"
                      x="-15" y="-40" width="30" height="8"
                      fill="hsl(calc(300 + var(--bifurcation-index) * 60), 70%, 50%)"
                      opacity="calc(0.4 + var(--bifurcation-index) * 0.6)"/>

                <!-- Digit shell display -->
                <text id="shell-display" x="0" y="-50"
                      text-anchor="middle" font-size="12" fill="#fff" opacity="0.8">
                    Shell: 1
                </text>

                <!-- Current position -->
                <text id="position-display" x="0" y="50"
                      text-anchor="middle" font-size="14" fill="#4ecdc4" opacity="0.9">
                    x = 1
                </text>

                <!-- 9/11 charge indicator -->
                <circle id="q911-indicator"
                        cx="0" cy="-25"
                        r="calc(4 + var(--q911-value) * 6)"
                        fill="hsl(calc(300 + var(--q911-value) * 60), 70%, 60%)"
                        opacity="calc(0.3 + var(--q911-value) * 0.7)"/>
            </g>
        </svg>
        <div class="status" id="outputStatus">Initializing AntClock...</div>
    </div>

    <script>
        const video = document.getElementById('feed');
        const canvas = document.getElementById('analyzer');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const svg = document.getElementById('mirror');
        const inputStatus = document.getElementById('inputStatus');
        const outputStatus = document.getElementById('outputStatus');

        let frameCount = 0;
        let t = 0;
        let useSyntheticTest = false;

        // AntClock Declarative Operators
        // These functions compute values that are stored in SVG antclock elements

        // Curvature operator: κ_n = r_{n+1} - 2r_n + r_{n-1}
        function computeCurvature(n) {
            if (n <= 0) return 0.0;

            const r = (k) => {
                if (k <= 0) return 0.0;
                const center = Math.floor(k / 2);
                try {
                    // Use Stirling's approximation for large binomials
                    if (k > 100) {
                        const logBinom = k * Math.log(k) - k - (k - center) * Math.log(k - center) -
                                       center * Math.log(center) + 0.5 * Math.log(2 * Math.PI * k / ((k - center) * center));
                        return logBinom;
                    }
                    return Math.log(binomial(k, center));
                } catch {
                    return 0.0;
                }
            };

            return r(n + 1) - 2 * r(n) + r(n - 1);
        }

        // Binomial coefficient helper
        function binomial(n, k) {
            if (k < 0 || k > n) return 0;
            if (k === 0 || k === n) return 1;

            let result = 1;
            for (let i = 1; i <= k; i++) {
                result = result * (n - k + i) / i;
            }
            return result;
        }

        // Digit mirror operator: μ₇(d) = d^7 mod 10
        function digitMirrorOperator(d) {
            return Math.pow(d, 7) % 10;
        }

        // Mirror phase: n mod 4 (discrete tangent singularities)
        function getMirrorPhase(n) {
            return n % 4;
        }

        // Digit count (shell index)
        function getDigitCount(n) {
            if (n === 0) return 1;
            return Math.floor(Math.log10(Math.abs(n))) + 1;
        }

        // 9/11 charge: Q(x) = N_9(x) / (N_0(x) + 1)
        function computeNineElevenCharge(x) {
            if (x === 0) return 0.0;

            const digits = Math.abs(x).toString().split('').map(d => parseInt(d));
            const nNines = digits.filter(d => d === 9).length;
            const nZeros = digits.filter(d => d === 0).length;

            return nNines / (nZeros + 1);
        }

        // Bifurcation index: B_t = floor(-log|c_t - c_*| / log(δ_FEG))
        function computeBifurcationIndex(cT, cStar = 0.0, deltaFeg = 0.1) {
            if (Math.abs(cT - cStar) < 1e-10) return 100; // Very high bifurcation

            try {
                const logTerm = -Math.log(Math.abs(cT - cStar)) / Math.log(deltaFeg);
                return Math.max(0, Math.floor(logTerm));
            } catch {
                return 0;
            }
        }

        // AntClock state (declarative)
        let currentX = 1;
        let clockPhase = 0.0;
        let chiFeg = 0.638;
        let trajectoryPoints = [{x: 0, y: 0}]; // For path visualization

        // Synthetic test data generator
        function generateSyntheticFrame() {
            const width = 320;
            const height = 240;
            const imageData = new ImageData(width, height);

            // Generate patterns that influence AntClock evolution
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;

                    // Create patterns that generate different number ranges
                    const wave1 = Math.sin(x * 0.02 + t * 0.5) * 127 + 128;
                    const wave2 = Math.sin(y * 0.02 + t * 0.3) * 127 + 128;
                    const wave3 = Math.sin((x + y) * 0.01 + t * 0.1) * 127 + 128;

                    imageData.data[idx] = wave1;
                    imageData.data[idx + 1] = wave2;
                    imageData.data[idx + 2] = wave3;
                    imageData.data[idx + 3] = 255;
                }
            }

            return imageData;
        }

        // Initialize AntClock system
        async function init() {
            try {
                // Try camera first, fallback to synthetic
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { width: 640, height: 480 }
                    });
                    video.srcObject = stream;
                    inputStatus.textContent = 'Camera active';
                    console.log('Using camera for AntClock evolution');
                } catch (cameraErr) {
                    console.log('Camera not available, using synthetic mode');
                    inputStatus.textContent = 'Synthetic test mode';
                    useSyntheticTest = true;
                }

                // Initialize AntClock CSS custom properties
                document.documentElement.style.setProperty('--phase-angle', '0');
                document.documentElement.style.setProperty('--mirror-phase', '0');
                document.documentElement.style.setProperty('--curvature-value', '0');
                document.documentElement.style.setProperty('--bifurcation-index', '0');
                document.documentElement.style.setProperty('--q911-value', '0');

                // Wait for video or start immediately
                if (!useSyntheticTest) {
                    video.addEventListener('loadeddata', () => {
                        console.log('Video ready, starting AntClock');
                        requestAnimationFrame(antClockLoop);
                    });

                    video.addEventListener('error', (e) => {
                        console.error('Video error:', e);
                        inputStatus.textContent = 'Video error - using synthetic';
                        useSyntheticTest = true;
                        requestAnimationFrame(antClockLoop);
                    });
                } else {
                    requestAnimationFrame(antClockLoop);
                }

            } catch (err) {
                console.error('AntClock initialization error:', err);
                inputStatus.textContent = 'Init error: ' + err.message;
                // Run anyway with synthetic data
                useSyntheticTest = true;
                requestAnimationFrame(antClockLoop);
            }
        }

        // AntClock Main Loop: video → numbers → AntClock walker → declarative visualization
        function antClockLoop() {
            let imagedata;

            if (useSyntheticTest) {
                imagedata = generateSyntheticFrame();
            } else if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                imagedata = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                requestAnimationFrame(antClockLoop);
                return;
            }

            // Extract features from video to generate numbers for AntClock evolution
            const features = extractVideoFeatures(imagedata);
            const generatedNumber = generateNumberFromFeatures(features);

            // Update AntClock walker declaratively
            updateAntClockWalker(generatedNumber);

            // Update visualization
            updateAntClockVisualization();

            frameCount++;
            t = frameCount * 0.016;

            requestAnimationFrame(antClockLoop);
        }

        // Extract features from video frame
        function extractVideoFeatures(imagedata) {
            const data = imagedata.data;
            const width = imagedata.width;
            const height = imagedata.height;

            // Compute basic statistics
            let rSum = 0, gSum = 0, bSum = 0, lumSum = 0;
            let pixelCount = 0;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i] / 255;
                const g = data[i + 1] / 255;
                const b = data[i + 2] / 255;
                const lum = (r + g + b) / 3;

                rSum += r;
                gSum += g;
                bSum += b;
                lumSum += lum;
                pixelCount++;
            }

            const avgR = rSum / pixelCount;
            const avgG = gSum / pixelCount;
            const avgB = bSum / pixelCount;
            const avgLum = lumSum / pixelCount;

            // Compute variance for "complexity"
            let variance = 0;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i] / 255;
                const g = data[i + 1] / 255;
                const b = data[i + 2] / 255;
                const lum = (r + g + b) / 3;
                variance += Math.pow(lum - avgLum, 2);
            }
            variance /= pixelCount;

            return {
                avgR, avgG, avgB, avgLum,
                variance,
                width, height
            };
        }

        // Generate number from video features for AntClock evolution
        function generateNumberFromFeatures(features) {
            // Convert video features to a number that drives AntClock
            const baseNumber = Math.floor(
                features.avgR * 100 +
                features.avgG * 50 +
                features.avgB * 25 +
                features.variance * 1000
            );

            // Add time-based evolution to ensure progression
            const timeComponent = Math.floor(t * 10);
            return Math.max(1, baseNumber + timeComponent);
        }

        // Update AntClock walker declaratively
        function updateAntClockWalker(inputNumber) {
            // Use input number to influence evolution rate, but maintain walker progression
            const evolutionRate = Math.max(1, Math.floor(inputNumber / 1000));

            // Evolve the walker
            for (let i = 0; i < evolutionRate; i++) {
                currentX += 1;

                // Compute AntClock values declaratively
                const curvature = computeCurvature(currentX);
                const mirrorPhase = getMirrorPhase(currentX);
                const digitShell = getDigitCount(currentX);
                const q911 = computeNineElevenCharge(currentX);
                const bifurcationIndex = computeBifurcationIndex(curvature);

                // Update clock phase
                const clockRate = chiFeg * Math.abs(curvature) * (1 + q911);
                clockPhase += clockRate;

                // Update trajectory
                const radius = digitShell * 20; // Scale for visualization
                const angle = clockPhase;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);

                trajectoryPoints.push({x, y});
                if (trajectoryPoints.length > 200) { // Keep recent history
                    trajectoryPoints.shift();
                }

                // Update declarative operators
                updateAntClockElements(currentX, curvature, mirrorPhase, digitShell, q911, bifurcationIndex);
            }
        }

        // Update AntClock declarative elements
        function updateAntClockElements(x, curvature, mirrorPhase, digitShell, q911, bifurcationIndex) {
            const walkerEl = document.getElementById('antclock-walker');
            const curvatureEl = document.getElementById('antclock-curvature');
            const phaseEl = document.getElementById('antclock-phase');
            const shellEl = document.getElementById('antclock-shell');
            const chargeEl = document.getElementById('antclock-charge');

            if (walkerEl) {
                walkerEl.setAttribute('x', x.toString());
            }
            if (curvatureEl) {
                curvatureEl.setAttribute('n', x.toString());
                curvatureEl.setAttribute('string', curvature.toFixed(6));
            }
            if (phaseEl) {
                phaseEl.setAttribute('angle', clockPhase.toFixed(6));
                phaseEl.setAttribute('mirrorPhase', mirrorPhase.toString());
            }
            if (shellEl) {
                shellEl.setAttribute('digitCount', digitShell.toString());
                shellEl.setAttribute('bifurcationIndex', bifurcationIndex.toString());
            }
            if (chargeEl) {
                chargeEl.setAttribute('q911', q911.toFixed(6));
                const mirrorOp = digitMirrorOperator(Math.floor(x / 10) % 10);
                chargeEl.setAttribute('mirrorOperator', mirrorOp.toString());
            }
        }

        // Update visualization based on declarative state
        function updateAntClockVisualization() {
            // Read from declarative operators and update CSS custom properties
            const phaseEl = document.getElementById('antclock-phase');
            const curvatureEl = document.getElementById('antclock-curvature');
            const shellEl = document.getElementById('antclock-shell');
            const chargeEl = document.getElementById('antclock-charge');

            if (phaseEl) {
                const angle = parseFloat(phaseEl.getAttribute('angle') || '0');
                const mirrorPhase = parseFloat(phaseEl.getAttribute('mirrorPhase') || '0');
                document.documentElement.style.setProperty('--phase-angle', angle.toString());
                document.documentElement.style.setProperty('--mirror-phase', mirrorPhase.toString());
            }

            if (curvatureEl) {
                const curvature = parseFloat(curvatureEl.getAttribute('string') || '0');
                document.documentElement.style.setProperty('--curvature-value', curvature.toString());
            }

            if (shellEl) {
                const bifurcationIndex = parseFloat(shellEl.getAttribute('bifurcationIndex') || '0');
                const digitShell = parseFloat(shellEl.getAttribute('digitCount') || '1');
                document.documentElement.style.setProperty('--bifurcation-index', bifurcationIndex.toString());
                document.documentElement.style.setProperty('--digit-shell', digitShell.toString());
            }

            if (chargeEl) {
                const q911 = parseFloat(chargeEl.getAttribute('q911') || '0');
                document.documentElement.style.setProperty('--q911-value', q911.toString());
            }

            // Update trajectory path
            updateTrajectoryPath();

            // Update status display
            updateStatusDisplay();
        }

        // Update the trajectory path visualization
        function updateTrajectoryPath() {
            const pathEl = document.getElementById('walker-path');
            if (!pathEl || trajectoryPoints.length < 2) return;

            const width = svg.clientWidth || 640;
            const height = svg.clientHeight || 480;
            const centerX = width / 2;
            const centerY = height / 2;

            // Scale trajectory to fit in unit circle area
            const scale = 120 / Math.max(150, ...trajectoryPoints.map(p => Math.sqrt(p.x * p.x + p.y * p.y)));

            let pathData = '';
            trajectoryPoints.forEach((point, i) => {
                const x = centerX + point.x * scale;
                const y = centerY + point.y * scale;
                pathData += (i === 0 ? 'M' : 'L') + ` ${x} ${y}`;
            });

            pathEl.setAttribute('d', pathData);
        }

        // Update status display
        function updateStatusDisplay() {
            const walkerEl = document.getElementById('antclock-walker');
            const shellEl = document.getElementById('antclock-shell');

            if (walkerEl && shellEl) {
                const x = walkerEl.getAttribute('x') || '1';
                const shell = shellEl.getAttribute('digitCount') || '1';

                // Update HUD text elements
                const shellDisplay = document.getElementById('shell-display');
                const positionDisplay = document.getElementById('position-display');

                if (shellDisplay) shellDisplay.textContent = `Shell: ${shell}`;
                if (positionDisplay) positionDisplay.textContent = `x = ${x}`;

                outputStatus.textContent = `AntClock: x=${x} | Shell=${shell} | Phase=${(clockPhase % (2 * Math.PI)).toFixed(2)} | Riemann ζ(s) analogue`;
            }
        }

        // Start AntClock system
        init();
    </script>
</body>
</html>
